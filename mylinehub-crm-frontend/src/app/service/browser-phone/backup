// import { Injectable, OnDestroy } from '@angular/core';
// import { UserAgent,Registerer,RegistererState,SubscriptionState,Subscriber,Inviter,SessionState, UserAgentOptions, Invitation, Session, Referral, InvitationAcceptOptions, Messager} from 'sip.js';
// import { Subject } from 'rxjs';
// import * as moment from 'moment';
// import { ConstantsService } from '../constants/constants.service';
// import { HeaderVariableService } from '../header-variable/header-variable.service';
// import { PhoneMusicService } from '../phone-music/phone-music.service';
// import { DialogComponent } from '../../pages/employee/all-employees/dialog/dialog.component';
// import { NbDialogService } from '@nebular/theme';
// import { XMLParser, XMLBuilder } from 'fast-xml-parser';

// @Injectable({
//   providedIn: 'root'
// })
//  export class BrowserPhoneService implements OnDestroy {

//   appversion:any = "0.0.1";
//   sipjsversion:any = "0.20.0";
//   userAgent:any="";
//   registerer:any="";
//   userAgentStr:any ;
  
//   //This letiable is used to do async tasks
//   sendAync:any;
//   sendAyncObserver: any;

//   enableRingtone:any = true;
//   //createSipUserAgent Method letiables
//   // Time in seconds before automatic Busy Here sent
//   noAnswerTimeout: any = 120;
//   // The timeout in seconds for the initial connection to make on the web socket port
//   transportConnectionTimeout: any = 1500;
//   // SDP Media Bundle: max-bundle | max-compat | balanced https://webrtcstandards.info/sdp-bundle/
//   bundlePolicy: any = 'balanced'; 
//   //Need to check below                 
//   registerContactParams: any="";
//   // Registration expiry time (in seconds)
//   registerExpires: any = 3000;
//   registerExtraHeaders: any="";
//   registerExtraContactParams: any="";
//   // Sets the JSON string for ice Server. Default: [{ "urls": "stun:stun.l.google.com:19302" }] Must be https://developer.mozilla.org/en-US/docs/Web/API/RTCConfiguration/iceServers
//   iceStunServerJson:any = "";
//   iceStunCheckTimeout:any = 500;        
//   ipInContact:any = 1; 
//     // Set the transport parameter to wss when used in SIP URIs. (Required for Asterisk as it doesn't support Path)
//   wssInTransport:any = 1;     
//   // Asterisk Phone DID length (Our extensions are of length 3. This has to be changed accordingly)
//   didLength: any = 3;
//   // The number of times to attempt to reconnect to a WebSocket when the connection drops.
//   transportReconnectionAttempts: any = 999;
//   // The time in seconds to wait between WebSocket reconnection attempts.
//   transportReconnectionTimeout: number = 300;

//   //Enlish language is loaded initially, if we need support for others then first we may need to get jason and define current language accordingly. This will have to make changes in constructor
//   lang: any = {};

//   streamBuffer :any=  50; 
//   incommingCallSessionData : any  = '';
//   currentConnectedSessionData : any  = '';

//   constructor(protected constService : ConstantsService,
//               protected headerVariableService : HeaderVariableService,
//               protected phoneMusicService:PhoneMusicService,
//               private dialogService: NbDialogService,) {
//                 this.startSendAync();
//                 //By Default we have choosen language as english although this could have been changed to other languages from here for browser phone information
//                 this.lang = this.constService.en;
//                 this.userAgentStr = "Mylinehub Phone "+ this.appversion +" (SIPJS - "+ this.sipjsversion +") "+ this.headerVariableService.navuserAgent;   // Set this to whatever you want.
//             }

//     startSendAync()  
//     {
//           //console.log("creating obserable first time ...")
//           this.sendAync = new Subject();
//           this.sendAyncObserver = this.sendAync.subscribe((data:any)=>{
//             if(data)
//             {
//                   switch(data)
//                 {
//                   case 'createSipUserAgent':
//                  //console.log("createUserAgent aync request initilated ...")
//                   this.createSipUserAgent();
//                   break;
//                   default:
//                  //console.log("deafult called, may be initializing first time ...")
//                   //console.log(data)
//                   break;
//                 }
//             }
//           });

//           //console.log("sending default string to verify ...")
//           this.sendAync.next('default data');
        
//     }  


//     //SIP Methods 

    
//     createSipUserAgent() {
//       //console.log("Creating User Agent...");
//       let sipUserAgentoptions:any = {};
//         if(!(ConstantsService.user.domain==null || ConstantsService.user.domain=="" || ConstantsService.user.domain=="null" || ConstantsService.user.domain=="undefined")) //ConstantsService.user.domain = ConstantsService.user.domain; // Sets globally
//         {
//             sipUserAgentoptions = {
//             uri: UserAgent.makeURI("sip:"+ ConstantsService.user.extension + "@" + ConstantsService.user.domain),
//             transportOptions: {
//                 server: "wss://" + ConstantsService.user.domain + ":"+ ConstantsService.user.sipPort +""+ ConstantsService.user.sipPath,
//                 traceSip: false,
//                 connectionTimeout: this.transportConnectionTimeout
//                 // keepAliveInterval: 30 // Uncomment this and make this any number greater then 0 for keep alive... 
//                 // NB, adding a keep alive will NOT fix bad internet, if your connection cannot stay open (permanent WebSocket Connection) you probably 
//                 // have a router or ISP issue, and if your internet is so poor that you need to some how keep it alive with empty packets
//                 // upgrade you internet connection. This is voip we are talking about here.
//             },
//             sessionDescriptionHandlerFactoryOptions: {
//                 peerConnectionConfiguration :{
//                     bundlePolicy: this.bundlePolicy,
//                     // certificates: undefined,
//                     // iceCandidatePoolSize: 10,
//                     iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
//                     // iceTransportPolicy: "all",
//                     // peerIdentity: undefined,
//                     // rtcpMuxPolicy: "require",
//                 },
//                 iceGatheringTimeout: this.iceStunCheckTimeout
//             },
//            // contactName: ConstantsService.user.extension,
//             displayName: ConstantsService.user.firstName + " " + ConstantsService.user.lastName,
//             authorizationUsername: ConstantsService.user.extension,
//             authorizationPassword: ConstantsService.user.extensionpassword,
//             userAgentString: this.userAgentStr,
//             autoStart: false,
//             autoStop: true,
//             register: false,
//             noAnswerTimeout: this.noAnswerTimeout,
//             // sipExtension100rel: // UNSUPPORTED | SUPPORTED | REQUIRED NOTE: rel100 is not supported
//             delegate: {
//                 onInvite: (sip:any)=>{
//                 //   console.log("Invite received");
//                 //   console.log(typeof sip);
//                 //   console.log(JSON.stringify(sip));

//                   this.receiveCall(sip);
//                 },
//                 onMessage: (sip:any)=>{
//                     console.log("Message received");
//                     this.receiveOutOfDialogMessage(sip);
//                 }
//             }
//             }
//         }
//         else
//         {
//             //Dialod showing domain ijs null
//             this.showDialoge('Error','activity-outline','danger', "Doamin in database for user is null. Kindly report to admin."); 
          
//         }

//         if(this.iceStunServerJson != ""){
//             sipUserAgentoptions.sessionDescriptionHandlerFactoryOptions.peerConnectionConfiguration.iceServers = JSON.parse(this.iceStunServerJson);
//         }

//         // Added to the contact BEFORE the '>' (permanent)
//         if(this.registerContactParams && this.registerContactParams != "" && this.registerContactParams != "{}"){
//             try{
//                 sipUserAgentoptions.contactParams = JSON.parse(this.registerContactParams);
//             } catch(e){}
//         }
//         if(this.wssInTransport){
//             try{
//                 sipUserAgentoptions.contactParams["transport"] = "wss";
//             } catch(e){}
//         }

//         // Add (Hardcode) other RTCPeerConnection({ rtcConfiguration }) config dictionary options here
//         // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/RTCPeerConnection
//         // Example: 
//         // options.sessionDescriptionHandlerFactoryOptions.peerConnectionConfiguration.rtcpMuxPolicy = "require";
        
//         this.userAgent = new UserAgent(sipUserAgentoptions);
//         this.userAgent.isRegistered = ()=>{
//             return (this.userAgent && this.userAgent.registerer && this.userAgent.registerer.state == RegistererState.Registered);
//         }
//         // For some reason this is marked as private... not sure why
//         this.userAgent.sessions = this.userAgent._sessions;
//         this.userAgent.registrationCompleted = false;
//         this.userAgent.registering = false;
//         this.userAgent.transport.reconnectionAttempts = this.transportReconnectionAttempts;
//         this.userAgent.transport.attemptingReconnection = false;
//         this.userAgent.BlfSubs = [];
//         this.userAgent.lastVoicemailCount = 0;

//       //console.log("Creating User Agent... Done");

//         this.userAgent.transport.onConnect = ()=>{
//             this.onTransportConnected();
//         }
//         this.userAgent.transport.onDisconnect = (error:any)=>{
//             if(error){
//                 this.onTransportConnectError(error);
//             }
//             else {
//                 this.onTransportDisconnected();
//             }
//         }

//         let RegistererOptions = { 
//             expires: this.registerExpires,
//             extraHeaders: [],
//             extraContactHeaderParams: []
//         }

//         // Added to the SIP Headers
//         if(this.registerExtraHeaders && this.registerExtraHeaders != "" && this.registerExtraHeaders != "{}"){
//             try{
//                 let registerExtraHeaders = JSON.parse(this.registerExtraHeaders);
//                 for (const [key, value] of Object.entries(registerExtraHeaders)) {
//                     if(value != ""){
//                         RegistererOptions.extraHeaders.push(key + ": "+  value);
//                     }
//                 }
//             } catch(e){}
//         }

//         // Added to the contact AFTER the '>' (not permanent)
//         if(this.registerExtraContactParams && this.registerExtraContactParams != "" && this.registerExtraContactParams != "{}"){
//             try{
//                 let registerExtraContactParams = JSON.parse(this.registerExtraContactParams);
//                 for (const [key, value] of Object.entries(registerExtraContactParams)) {
//                     if(value == ""){
//                         RegistererOptions.extraContactHeaderParams.push(key);
//                     } else {
//                         RegistererOptions.extraContactHeaderParams.push(key + ":"+  value);
//                     }
//                 }
//             } catch(e){}
//         }

//         this.userAgent.registerer = new Registerer(this.userAgent, RegistererOptions);
//       //console.log("Creating Registerer... Done");

//         this.userAgent.registerer.stateChange.addListener((newState:any)=>{
//           //console.log("User Agent Registration State:", newState);
//             switch (newState) {
//                 case RegistererState.Initial:
//                     // Nothing to do, just printing lof inside below function
//                     this.onInitial();
//                     break;
//                 case RegistererState.Registered:
//                     this.onRegistered();
//                     break;
//                 case RegistererState.Unregistered:
//                     this.onUnregistered();
//                     break;
//                 case RegistererState.Terminated:
//                     // Nothing to do, just printing lof inside below function
//                     this.onTerminated();
//                     break;
//             }
//         });

//       //console.log("User Agent Connecting to WebSocket...");
//         this.headerVariableService.browserPhoneTitle = this.lang.connecting_to_web_socket;
//         this.userAgent.start().catch((error:any)=>{
//             this.onTransportConnectError(error);
//         });
//     }

    
//     sendChatMessage(message:any,extension:any,domain:any) {
//         if (this.userAgent == null) return;
//         if (!this.userAgent.isRegistered()) return;
//         var messageId = this.uID();

//         // Update Stream
//         let DateTime = moment.utc().format("YYYY-MM-DD HH:mm:ss UTC");
    
//         // SIP Messages (Note, this may not work as required)
//         // ============
//         let chatBuddy = UserAgent.makeURI("sip:"+ extension + "@" + domain);
//         console.log("MESSAGE: "+ chatBuddy + " (extension)");

//         var MessagerMessageOptions = {
//                 requestDelegate : {
//                     onAccept: (sip:any)=>{
//                         console.log("Message Accepted:", messageId);
//                         // MarkMessageSent(buddyObj, messageId, true);
//                     },
//                     onReject: (sip:any)=>{
//                         console.warn("Message Error", sip.message.reasonPhrase);
//                         // MarkMessageNotSent(buddyObj, messageId, true);
//                         this.showDialoge('Error','activity-outline','danger', "Error while sending message with reason : "+sip.message.reasonPhrase);
//                     }
//                 },
//                 requestOptions : {
//                     extraHeaders: [],
//                 }
//             };
			
//         var messageObj = new Messager(this.userAgent, chatBuddy, message, "text/plain");
			
//         messageObj.message(MessagerMessageOptions).then(function(){
//                 // Custom Web hook
//                 // if(typeof web_hook_on_message !== 'undefined') web_hook_on_message(messageObj);
//             });
//     }

//         // Transport Events
//       // ================
//     onTransportConnected(){
//         //console.log("I am in onTransportConnected");
//         //console.log("Connected to Web Socket!");
//         this.headerVariableService.browserPhoneTitle=this.lang.connected_to_web_socket;
  
  
//           // Reset the ReconnectionAttempts
//           this.userAgent.isReRegister = false;
//           this.userAgent.transport.attemptingReconnection = false;
//           this.userAgent.transport.ReconnectionAttempts = this.transportReconnectionAttempts;
  
//           // Auto start register
//           if(this.userAgent.transport.attemptingReconnection == false && this.userAgent.registering == false){
//               window.setTimeout(()=>{
//                   this.register();
//               }, 500);
//           } else{
//             console.warn("onTransportConnected: register() called, but attemptingReconnection is true or registering is true")
//           }
//       }
  
//     onTransportConnectError(error:any){

//         //console.log("I am in onTransportConnectError");

//         console.warn("WebSocket Connection Failed:", error);
  
//           // We set this flag here so that the re-register attempts are fully completed.
//           this.userAgent.isReRegister = false;
  
//           // If there is an issue with the WS connection
//           // We unregister, so that we register again once its up
//         //console.log("Unregister...");
//           try{
//               this.userAgent.registerer.unregister();
//           } catch(e){
//               // I know!!!
//           }
  
//           this.headerVariableService.browserPhoneTitle=this.lang.web_socket_error;
//           this.headerVariableService.browserPhoneTitle=this.lang.unregistered;
//           this.headerVariableService.isBrowserPhoneOnline = false;
//           this.headerVariableService.isOnlineStatus = "danger";

//           this.reconnectTransport();
  
//       }
  
//     onTransportDisconnected(){
//         //console.log("I am in onTransportDisconnected");

//         //console.log("Disconnected from Web Socket!");
//         this.headerVariableService.browserPhoneTitle=this.lang.disconnected_from_web_socket;
  
//           this.userAgent.isReRegister = false;
//           this.headerVariableService.browserPhoneTitle=this.lang.unregistered;
//           this.headerVariableService.isBrowserPhoneOnline = false;
//           this.headerVariableService.isOnlineStatus = "danger";
//       }
  
  
//     reconnectTransport(){

//         //console.log("I am in reconnectTransport");

//           if(this.userAgent == null) return;
      
//           this.userAgent.registering = false; // if the transport was down, you will not be registered
//           if(this.userAgent.transport && this.userAgent.transport.isConnected()){
//               // Asked to re-connect, but ws is connected
//               this.onTransportConnected();
//               return;
//           }
//           //console.log("Reconnect Transport...");
      
//           window.setTimeout(()=>{
//               // $("#regStatus").html(this.lang.connecting_to_web_socket);
//               //console.log("ReConnecting to WebSocket...");
      
//               if(this.userAgent.transport && this.userAgent.transport.isConnected()){
//                   // Already Connected
//                   this.onTransportConnected();
//                   return;
//               } else {
//                   this.userAgent.transport.attemptingReconnection = true
//                   this.userAgent.reconnect().catch((error:any)=>{
//                       this.userAgent.transport.attemptingReconnection = false
//                       console.warn("Failed to reconnect", error);
      
//                       // Try Again
//                       this.reconnectTransport();
//                   });
//               }
//           }, this.transportReconnectionTimeout * 1000);
      
//           this.headerVariableService.browserPhoneTitle = this.lang.connecting_to_web_socket;
//           //console.log("Waiting to Re-connect...", this.transportReconnectionTimeout, "Attempt remaining", this.userAgent.transport.reconnectionAttempts);
//           this.userAgent.transport.reconnectionAttempts = this.userAgent.transport.reconnectionAttempts - 1;
//       }

    
//     // Registration
//     // ============
//     register() {

//         //console.log("I am in register");

//         if (this.userAgent == null) return;
//         if (this.userAgent.registering == true) return;
//         if (this.userAgent.isRegistered()) return;
  
//         let RegistererRegisterOptions = {
//             requestDelegate: {
//                 onReject: (sip:any)=>{
//                     this.onRegisterFailed(sip.message.reasonPhrase, sip.message.statusCode);
                    
//                 }
//             }
//         }
  
//         //console.log("Sending Registration...");
//         this.userAgent.registering = true
//         this.userAgent.registerer.register(this.userAgent,RegistererRegisterOptions);
//         this.headerVariableService.browserPhoneTitle=this.lang.connected_to_web_socket;
//       }
  
//     unregister(skipUnsubscribe:any) {

//         //console.log("I am in unregister");

//         if (this.userAgent == null || !this.userAgent.isRegistered()) return;
  
//         if(skipUnsubscribe == true){
//           //console.log("Skipping Unsubscribe");
//         } else {
//           //console.log("Unsubscribing...");
//           this.headerVariableService.browserPhoneTitle=this.lang.unsubscribing;
//             try {
//               this.unsubscribeAll();
//             } catch (e) { }
//         }
  
//       //console.log("Unregister...");
//       this.headerVariableService.browserPhoneTitle=this.lang.disconnecting;
//         this.userAgent.registerer.unregister();
  
//         this.userAgent.transport.attemptingReconnection = false;
//         this.userAgent.registering = false;
//         this.userAgent.isReRegister = false;
//       }
  
//       // Registration Events
//       // ===================
//       /**
//       * Called when account is registered
//       */
//     onRegistered(){
//         // This code fires on re-register after session timeout
//         // to ensure that events are not fired multiple times
//         // a isReRegister state is kept.
//         // TODO: This check appears obsolete
//         //console.log("I am in onRegistered");
//         this.userAgent.registrationCompleted = true;
//         if(!this.userAgent.isReRegister) {
//           //console.log("Registered!");
  
//            // Start Subscribe Loop
//             window.setTimeout(()=>{
//                 this.subscribeAll();
//             }, 500);
  
//             // Start XMPP
//           // if(this.chatEngine == "XMPP") this.reconnectXmpp();
  
//             this.userAgent.registering = false;
  
//         }
//         else {
//             this.userAgent.registering = false;
  
//           //console.log("ReRegistered!");
//         }
//         this.userAgent.isReRegister = true;
//         this.headerVariableService.browserPhoneTitle=this.lang.registered;
//         this.headerVariableService.isBrowserPhoneOnline = true;
//         this.headerVariableService.isOnlineStatus = "success";

//       }
  
  
//       /**
//       * Called if this.userAgent can connect, but not register.
//       * @param {string} response Incoming request message
//       * @param {string} cause Cause message. Unused
//       **/
//     onRegisterFailed(response:any, cause:any){
//       //console.log("I am in onRegisterFailed");
//       //console.log("Registration Failed: " + response);
//       this.headerVariableService.browserPhoneTitle=this.lang.registration_failed;
//         this.showDialoge('Registration Failed','activity-outline','danger', this.lang.registration_failed); 
//         this.userAgent.registering = false;
//         this.headerVariableService.browserPhoneTitle=this.lang.unregistered;
//         this.headerVariableService.isBrowserPhoneOnline = false;
//         this.headerVariableService.isOnlineStatus = "danger";
//       }
  
      
//       /**
//       * Called when Unregister is requested
//       */
      
//     onInitial()
//       {
//           //console.log("I am in onInitial");
//       }
  
//     onTerminated()
//       {
//           //console.log("I am in onTerminated");
//       }
  
  
//     onUnregistered(){

//         //console.log("I am in onUnregistered");

//         //console.log("Unregistered, bye! onUnregistered function");
//         // We set this flag here so that the re-register attempts are fully completed.
//         this.userAgent.isReRegister = false;
//         this.headerVariableService.browserPhoneTitle=this.lang.unregistered;
//         this.headerVariableService.isBrowserPhoneOnline = false;
//         this.headerVariableService.isOnlineStatus = "danger";
//       }
  

//      // Subscription Events
//   // ===================

//    // Presence / Subscribe
//     // ====================
//     subscribeAll() {

//         //console.log("I am in subscribeAll");

//         if(!this.userAgent.isRegistered()) return;
    
//         if(this.headerVariableService.voiceMailSubscribe){
//         this.subscribeVoicemail();
//         }
//         if(this.headerVariableService.subscribeToYourself){
//         this.selfSubscribe();
//         }
    
//         // Start subscribe all
//         if(this.userAgent.BlfSubs && this.userAgent.BlfSubs.length > 0){
//         this.unsubscribeAll();
//         }
//         this.userAgent.BlfSubs = [];
//     }

//     selfSubscribe(){

//         //console.log("I am in selfSubscribe");

//         if(!this.userAgent.isRegistered()) return;
    
//         if(this.userAgent.selfSub){
//             //console.log("Unsubscribe from old self subscribe...");
//             this.selfUnsubscribe();
//         }
    
//         let targetURI = UserAgent.makeURI("sip:"+ ConstantsService.user.extension + "@" + ConstantsService.user.domain);

    
    
//         let options:any = { 
//             expires: this.headerVariableService.subscribeExpires, 
//             extraHeaders: ['Accept: '+ this.headerVariableService.subscribeAccept]
//         }
    
//         this.userAgent.selfSub = new Subscriber(this.userAgent, targetURI, this.headerVariableService.subscribeBuddyEvent, options);
//         this.userAgent.selfSub.delegate = {
//             onNotify: (sip:any)=> {
//             this.receiveNotify(sip, true);
//             }
//         }
//         //console.log("SUBSCRIBE Self: "+ ConstantsService.user.extension +"@" + ConstantsService.user.domain);
//         this.userAgent.selfSub.subscribe().catch((error:any)=>{
//             console.warn("Error subscribing to yourself:", error);
//         });
//     }


    
//     subscribeVoicemail(){

//         //console.log("I am in subscribeVoicemail");

//         if(!this.userAgent.isRegistered()) return;
    
//         if(this.userAgent.voicemailSub){
//             //console.log("Unsubscribe from old voicemail Messages...");
//             this.unsubscribeVoicemail();
//         }
    
//         let vmOptions:any = { expires : this.headerVariableService.subscribeVoicemailExpires }
//         let targetURI = UserAgent.makeURI("sip:"+ ConstantsService.user.extension + "@" + ConstantsService.user.domain);
//         this.userAgent.voicemailSub = new Subscriber(this.userAgent, targetURI, "message-summary", vmOptions);
//         this.userAgent.voicemailSub.delegate = {
//             onNotify: (sip:any) =>{
//             this.voicemailNotify(sip);
//             }
//         }
//         //console.log("SUBSCRIBE VOICEMAIL: "+ ConstantsService.user.extension +"@" + ConstantsService.user.domain);
//         this.userAgent.voicemailSub.subscribe().catch((error:any)=>{
//             console.warn("Error subscribing to voicemail notifications:", error);
//         });
//     }
    
//     selfUnsubscribe(){

//         //console.log("I am in selfUnsubscribe");

//         if(!this.userAgent.isRegistered()) return;
    
//         if(this.userAgent.selfSub){
//             //console.log("Unsubscribe from yourself...", this.userAgent.selfSub.state);
//             if(this.userAgent.selfSub.state == SubscriptionState.Subscribed){
//             this.userAgent.selfSub.unsubscribe().catch((error:any)=>{
//                     console.warn("Error self subscription:", error);
//                 });
//             }
//             this.userAgent.selfSub.dispose().catch((error:any)=>{
//                 console.warn("Error disposing self subscription:", error);
//             });
//         } else {
//             //console.log("Not subscribed to Yourself");
//         }
//         this.userAgent.selfSub = null;
//     }
    
//     unsubscribeAll() {

//         //console.log("I am in unsubscribeAll");

//         if(!this.userAgent.isRegistered()) return;

//         //console.log("Unsubscribe from voicemail Messages...");
//         this.unsubscribeVoicemail();

//         if(this.userAgent.BlfSubs && this.userAgent.BlfSubs.length > 0){
//             //console.log("Unsubscribing "+ this.userAgent.BlfSubs.length + " subscriptions...");
//             for (let blf = 0; blf < this.userAgent.BlfSubs.length; blf++) {
//                 this.unsubscribeBlf(this.userAgent.BlfSubs[blf]);
//             }
//             this.userAgent.BlfSubs = [];
//         }
//     }

//     unsubscribeVoicemail(){

//         //console.log("I am in unsubscribeVoicemail");

//         if(!this.userAgent.isRegistered()) return;
    
//         if(this.userAgent.voicemailSub){
//             //console.log("Unsubscribe to voicemail Messages...", this.userAgent.voicemailSub.state);
//             if(this.userAgent.voicemailSub.state == SubscriptionState.Subscribed){
//             this.userAgent.voicemailSub.unsubscribe().catch((error:any)=>{
//                     console.warn("Error removing voicemail notifications:", error);
//                 });
//             }
//             this.userAgent.voicemailSub.dispose().catch((error:any)=>{
//                 console.warn("Error disposing voicemail notifications:", error);
//             });
//         } else {
//             //console.log("Not subscribed to MWI");
//         }
//         this.userAgent.voicemailSub = null;
//     }
    
//     unsubscribeBlf(blfSubscribe:any){

//         //console.log("I am in unsubscribeBlf");

//         if(!this.userAgent.isRegistered()) return;
    
//         if(blfSubscribe.state == SubscriptionState.Subscribed){
//             //console.log("Unsubscribe to BLF Messages...", ConstantsService.user.extension);
//             blfSubscribe.unsubscribe().catch((error:any)=>{
//                 console.warn("Error removing BLF notifications:", error);
//             });
//         } 
//         else {
//             //console.log("Incorrect buddy subscribe state", ConstantsService.user.extension, blfSubscribe.state);
//         }
//         blfSubscribe.dispose().catch((error:any)=>{
//             console.warn("Error disposing BLF notifications:", error);
//         });
//         blfSubscribe = null;
//     }

//     receiveOutOfDialogMessage(message:any) {
      
//       console.log("I am in receiveOutOfDialogMessage");
//       let callerID = message.request.from.displayName;
//       let did = message.request.from.uri.normal.user;
    
//       console.log("callerID : ",callerID);
//       console.log("did : ",did);
//       console.log("*************************************message start***************************************");
//       console.log(JSON.stringify(message));
//       console.log("*************************************message end***************************************");

//       // Out of dialog Message Receiver
//       let messageType = (message.request.headers["Content-Type"].length >=1)? message.request.headers["Content-Type"][0].parsed : "Unknown" ;
//       // Text Messages
//       if(messageType.indexOf("text/plain") > -1){
//           // Plain Text Messages SIP SIMPLE
//         //console.log("New Incoming Message!", "\""+ callerID +"\" <"+ did +">");
    
//           if(did.length > this.didLength) {
//               // Contacts cannot receive Test Messages, because they cannot reply
//               // This may change with FAX, Email, WhatsApp etc
//             console.warn("DID length greater then extensions length")
//               return;
//           }
    
//           let CurrentCalls = this.countSessions("0");
//           let originalMessage = message.request.body;
//           let messageId = this.uID();
//           let DateTime = this.utcDateNow();
    
//           message.accept();
    
//           //Write code to show text messages on header
//           this.showMessageOnHeader(messageId, "MSG", originalMessage, DateTime);
//           //dummy call for some extra work
//           this.refreshMessages("","");
//           this.ringMessageMusic(originalMessage);
//       }
//       // Message Summary
//       else if(messageType.indexOf("application/simple-message-summary") > -1){
//         console.warn("This message-summary is unsolicited (out-of-dialog). Consider using the SUBSCRIBE method.")
//           this.voicemailNotify(message);
//       }
//       else{
//         console.warn("Unknown Out Of Dialog Message Type: ", messageType);
//           message.reject();
//       }
    
//     }

//     showMessageOnHeader(messageId:any, type:any, message:any, DateTime:any){
//              //Write code to show text messages on header
//              //console.log("I am in showMessageOnHeader");
//          }
      
//     refreshMessages(Obj:any, filter:any) {

//         //console.log("I am in refreshMessages");

//       }


//     ringMessageMusic(message:any){
//         //console.log("I am in ringMessageMusic");
//         // Handle Stream Not visible
//         // =========================
//        // Play Alert
//        //console.log("Audio:", this.phoneMusicService.audioBlobs.Alert.url);
//        let ringer:any = new Audio(this.phoneMusicService.audioBlobs.Alert.blob);
//        ringer.preload = "auto";
//        ringer.loop = false;
//        ringer.oncanplaythrough = (e:any)=> {
//            if (typeof ringer.sinkId !== 'undefined' && this.headerVariableService.currentSpeakerStringValue != "default") {
//                ringer.setSinkId(this.headerVariableService.currentSpeakerStringValue).then(() =>{
//                    //console.log("Set sinkId to:", this.headerVariableService.currentSpeakerStringValue);
//                }).catch((e:any)=>{
//                    console.warn("Failed not apply setSinkId.", e);
//                });
//            }
//            //If there has been no interaction with the page at all... this page will not work
//            ringer.play().then(()=>{
//                // Audio Is Playing
//            }).catch((e)=>{
//                console.warn("Unable to play audio file.", e);
//            });
//        }
//        message.data.ringerObj = ringer;
//     }

    
//     receiveCall(session:any) {

//       console.log("I am in receiveCall");
//       //console.log("session:", session);

//       let callerID = session.remoteIdentity.displayName;
//       let did = session.remoteIdentity.uri.user;
//       if (typeof callerID === 'undefined') callerID = did;
    
//       console.log("New Incoming Call!", callerID +" <"+ did +">");
    
//       let CurrentCalls = this.countSessions(session.id);
//       //console.log("Current Call Count:", CurrentCalls);
    
      
//       let startTime = moment.utc();
//       session.data = {}
//       session.data.calldirection = "inbound";
//       session.data.terminateby = "";
//       session.data.src = did;
//       session.data.callstart = startTime.format("YYYY-MM-DD HH:mm:ss UTC");
//       let now = moment.utc();
//       let duration = moment.duration(now.diff(startTime));
//       let timeStr = this.formatShortDuration(duration.asSeconds());
//       session.data.callTimer = timeStr;
//       this.headerVariableService.timer = timeStr;

//       session.data.earlyReject = false;

//       // Detect Video
//       session.data.withvideo = false;

//       //console.log("Detecting call type");

//       if(session.request.body){
//           // Asterisk 13 PJ_SIP always sends m=video if endpoint has video codec,
//           // even if original invite does not specify video.
//           if(session.request.body.indexOf("m=video") > -1) {
//               //console.log("Video call");
//               session.data.withvideo = true;
//           }
//           else
//           {
//               //console.log("Audio call");
//           }
//       }
    
//       // Session Delegates
//       session.delegate = {
//           onBye: (sip:any)=>{
//             //console.log("Receive call onBye");
//             this.onSessionReceivedBye(session,sip)
//           },
//           onMessage: (sip:any)=>{
//             //console.log("Receive call onMessage");
//             this.onSessionReceivedMessage(session,sip);
//           },
//           onInvite: (sip:any)=>{
//             //console.log("Receive call onInvite");
//             this.onSessionReinvited(session,sip);
//           },
//           onSessionDescriptionHandler: (sdh:any, provisional:any)=>{
//             //console.log("Receive call onSessionDescriptionHandler");
//             this.onSessionDescriptionHandlerCreated(session,sdh, provisional, session.data.withvideo);
//           }
//       }
//       // incomingInviteRequestDelegate
//       session.incomingInviteRequest.delegate = {
//           onCancel: (sip:any)=>{
//             this.onInviteCancel(session,sip)
//           }
//       }

//       // Possible Early Rejection options
//       if(this.headerVariableService.doNotDisturb == true) {
//         //console.log("Do Not Disturb Enabled, rejecting call.");
//         session.data.earlyReject = true;
//         this.rejectCall(session);
//         return;
//       }
//       if(CurrentCalls >= 1){
//           if(this.headerVariableService.callWaiting == false ){
//             //console.log("Call Waiting Disabled, rejecting call.");
//               session.data.earlyReject = true;
//               this.rejectCall(session); 
//               return;
//           }
//       }
    
//       // Auto Answer options
//       let answerTimeout = 1000;
//       if(this.headerVariableService.autoAnswer){
//           if(CurrentCalls == 0){ // There are no other calls, so you can answer
//             //console.log("Going to Auto Answer this call...");
//               window.setTimeout(()=>{
//                   // If the call is with video, assume the auto answer is also
//                   // In order for this to work nicely, the recipient maut be "ready" to accept video calls
//                   // In order to ensure video call compatibility (i.e. the recipient must have their web cam in, and working)
//                   // The NULL video should be configured
//                   // https://github.com/InnovateAsterisk/Browser-Phone/issues/26
//                   if(session.data.withvideo) {
//                     this.answervideoCall(session);
//                   }
//                   else {
//                     this.answeraudioCall(session);
//                   }
//               }, answerTimeout);
//               return;
//           }
//           else {
//             console.warn("Could not auto answer call, already on a call.");
//           }
//       }

//       if(CurrentCalls == 0)
//       {
//         this.headerVariableService.callInProgress = false;
//         this.headerVariableService.callStatus = 'danger';
//       }
//        this.headerVariableService.callRinging = true;
//        //Assinging session to header to pass when person picks or rejects call. Hence window notification is not required. This notification UI is instead handled by application itself
//        this.incommingCallSessionData = session;
//        this.headerVariableService.callType= "Incoming-Call";
//        this.headerVariableService.callerName = callerID;
//        this.headerVariableService.phoneNumber = did;
//        this.headerVariableService.isVideoCall = session.data.withvideo;
//        this.headerVariableService.isInternal = (Number(did)==this.didLength);

//       // Play Ring Tone if not on the phone
//       if(this.enableRingtone == true){
//           if(CurrentCalls >= 1){
//               // Play Alert
//             //console.log("Audio:", this.phoneMusicService.audioBlobs.CallWaiting.url);
//               let ringer:any = new Audio(this.phoneMusicService.audioBlobs.CallWaiting.blob); 
//               ringer.preload = "auto";
//               ringer.loop = false;
//               ringer.oncanplaythrough = (e:any)=> {
//                   if (typeof ringer.sinkId !== 'undefined' && this.headerVariableService.currentMicStringValue != "default") {
//                       ringer.setSinkId(this.headerVariableService.currentMicStringValue).then(()=> {
//                         //console.log("Set sinkId to:", this.headerVariableService.currentMicStringValue);
//                       }).catch((e:any)=>{
//                         console.warn("Failed not apply setSinkId.", e);
//                       });
//                  }
//                   // If there has been no interaction with the page at all... this page will not work
//                   ringer.play().then(()=>{
//                       // Audio Is Playing
//                   }).catch((e:any)=>{
//                     console.warn("Unable to play audio file.", e);
//                   }); 
//               }
//               session.data.ringerObj = ringer;
//           } else {
//               // Play Ring Tone
//             //console.log("Audio:", this.phoneMusicService.audioBlobs.Ringtone.url);
//               let ringer:any = new Audio(this.phoneMusicService.audioBlobs.Ringtone.blob);
//               ringer.preload = "auto";
//               ringer.loop = true;
//               ringer.oncanplaythrough = (e:any)=> {
//                   if (typeof ringer.sinkId !== 'undefined' && this.headerVariableService.currentMicStringValue != "default") {
//                       ringer.setSinkId(this.headerVariableService.currentMicStringValue).then(()=> {
//                         //console.log("Set sinkId to:", this.headerVariableService.currentMicStringValue);
//                       }).catch((e:any)=>{
//                         console.warn("Failed not apply setSinkId.", e);
//                       });
//                  }
//                   // If there has been no interaction with the page at all... this page will not work
//                   ringer.play().then(()=>{
//                       // Audio Is Playing
//                   }).catch((e:any)=>{
//                     console.warn("Unable to play audio file.", e);
//                   }); 
//               }
//               session.data.ringerObj = ringer;
//           }
      
//       }
    
//     }

//     // Inbound Calls
//     // =============
//       answeraudioCall(sessionData:any) {

//         //console.log("I am in answeraudioCall");

//         // CloseWindow();
//         let session = sessionData;

//         //console.log("Got session data : ",session);

//         // Stop the ringtone
//         if(session.data.ringerObj){
//             session.data.ringerObj.pause();
//             session.data.ringerObj.removeAttribute('src');
//             session.data.ringerObj.load();
//             session.data.ringerObj = null;
//         }

//         //console.log("Stopped Ringing");

//         // Check vitals
//         if(this.headerVariableService.hasAudioDevice == false){

//           //console.log("System does not have audio device");

//           this.showDialoge('Error','activity-outline','danger', "No microphone found to receive incomming."); 
//           this.headerVariableService.callInProgress = false;
//           this.headerVariableService.callStatus = 'danger';
//           this.headerVariableService.callRinging = false;
//            return;
//         }

//         //console.log("System has audio device");
      
//         // Start SIP handling
//         let supportedConstraints = navigator.mediaDevices.getSupportedConstraints();

//         //console.log("supportedConstraints : ",supportedConstraints);

//         let spdOptions:any = {
//             sessionDescriptionHandlerOptions: {
//                 constraints: {
//                     audio: { deviceId : {}
//                               },
//                     video: false
//                 }
//             }
//         }
      
//         //console.log("Empty spdOptions created");

//         // Configure Audio
//         let currentAudioDevice = this.headerVariableService.currentMicStringValue;
//         if(currentAudioDevice != "default"){
//             let confirmedAudioDevice = false;
//             for (let i = 0; i < this.headerVariableService.micList.length; ++i) {
//                 if(currentAudioDevice == this.headerVariableService.micList[i]) {
//                     confirmedAudioDevice = true;
//                     break;
//                 }
//             }
//             if(confirmedAudioDevice) {
//                 spdOptions.sessionDescriptionHandlerOptions.constraints.audio.deviceId = { exact: currentAudioDevice };
//                 //console.log("Audio added to spdOptions.sessionDescriptionHandlerOptions.constraints.audio.deviceId");
//             }
//             else {
              
//                 console.warn("The audio device you used before is no longer available, default settings applied.");
//                 this.showDialoge('Error','activity-outline','danger', "The audio device you used before is no longer available, default settings applied."); 
//                 this.headerVariableService.callInProgress = false;
//                 this.headerVariableService.callStatus = 'danger';
//                 this.headerVariableService.callRinging = false;
//                  return;
//             }
//         }
//         // Add additional Constraints
//         if(supportedConstraints.autoGainControl) {
//             spdOptions.sessionDescriptionHandlerOptions.constraints.audio.autoGainControl = this.headerVariableService.autoGainControl;
//         }
//         if(supportedConstraints.echoCancellation) {
//             spdOptions.sessionDescriptionHandlerOptions.constraints.audio.echoCancellation = this.headerVariableService.echoCancellation;
//         }
//         if(supportedConstraints.noiseSuppression) {
//             spdOptions.sessionDescriptionHandlerOptions.constraints.audio.noiseSuppression = this.headerVariableService.noiseSeperation;
//         }
      
//         //console.log("As per supported constraints added autoGainControl,echoCancellation,noiseSuppression to spdOptions.sessionDescriptionHandlerOptions.constraints.audio");

//         // Save Devices
//         session.data.withvideo = false;
//         session.data.VideoSourceDevice = null;
//         session.data.AudioSourceDevice = this.headerVariableService.currentMicStringValue
//         session.data.AudioOutputDevice = this.headerVariableService.currentSpeakerStringValue;
      
//         //console.log("Added video , audio details");

//         //console.log("Accepting call");
//         // Send Answer
//         session.accept(spdOptions).then(()=>
//         {
//           //console.log("After accepting call, Calling now onInviteAccepted");
//           this.onInviteAccepted(session,false,'');
//         }).catch((error:any)=>
//         {
//             //console.log("Got error while receiving audio call. Please find below error details");
//             console.warn("Failed to answer call", error, session);
//             this.showDialoge('Failed to answer call','activity-outline','danger', error); 
//             session.data.reasonCode = 500;
//             session.data.reasonText = "Client Error";
//             this.teardownSession(session);
//         });
//       }
      
//       answervideoCall(sessionData:any) {
//         //console.log("I am in answervideoCall");
//         let session = sessionData;
//         // Stop the ringtone
//         if(session.data.ringerObj){
//             session.data.ringerObj.pause();
//             session.data.ringerObj.removeAttribute('src');
//             session.data.ringerObj.load();
//             session.data.ringerObj = null;
//         }
//         // Check vitals
//         if(this.headerVariableService.hasAudioDevice == false){
//           this.showDialoge('Error','activity-outline','danger', "No microphone found to receive incomming."); 
//           this.headerVariableService.callInProgress = false;
//           this.headerVariableService.callStatus = 'danger';
//             return;
//         }
      
//         // Start SIP handling
//         let supportedConstraints = navigator.mediaDevices.getSupportedConstraints();
//         let spdOptions = {
//             sessionDescriptionHandlerOptions: {
//                 constraints: {
//                     audio: { deviceId : {} },
//                     video: { deviceId : {} }
//                 }
//             }
//         }
      
//         // Configure Audio
//         let currentAudioDevice = this.headerVariableService.currentMicStringValue;
//         if(currentAudioDevice != "default"){
//             let confirmedAudioDevice = false;
//             for (let i = 0; i < this.headerVariableService.micList.length; ++i) {
//                 if(currentAudioDevice == this.headerVariableService.micList[i]) {
//                     confirmedAudioDevice = true;
//                     break;
//                 }
//             }
//             if(confirmedAudioDevice) {
//                 spdOptions.sessionDescriptionHandlerOptions.constraints.audio.deviceId = { exact: currentAudioDevice }
//             }
//             else {
//                 console.warn("The audio device you used before is no longer available, default settings applied.");
//                 this.showDialoge('Error','activity-outline','danger', "The audio device you used before is no longer available, default settings applied."); 
          
//             }
//         }
//         // Add additional Constraints
//         if(supportedConstraints.autoGainControl) {
//             spdOptions.sessionDescriptionHandlerOptions.constraints.audio["autoGainControl"] = this.headerVariableService.autoGainControl;
//         }
//         if(supportedConstraints.echoCancellation) {
//             spdOptions.sessionDescriptionHandlerOptions.constraints.audio["echoCancellation"] = this.headerVariableService.echoCancellation;
//         }
//         if(supportedConstraints.noiseSuppression) {
//             spdOptions.sessionDescriptionHandlerOptions.constraints.audio["noiseSuppression"] = this.headerVariableService.noiseSeperation;
//         }
      
//         // Configure Video
//         let currentVideoDevice = this.headerVariableService.currentVideoStringValue;
//         if(currentVideoDevice != "default"){
//             let confirmedVideoDevice = false;
//             for (let i = 0; i < this.headerVariableService.videoList.length; ++i) {
//                 if(currentVideoDevice == this.headerVariableService.videoList[i]) {
//                     confirmedVideoDevice = true;
//                     break;
//                 }
//             }
//             if(confirmedVideoDevice){
//                 spdOptions.sessionDescriptionHandlerOptions.constraints.video["deviceId"] = { exact: currentVideoDevice }
//             }
//             else {
//                 console.warn("The video device you used before is no longer available, default settings applied.");
//                 this.showDialoge('Error','activity-outline','danger', "The video device you used before is no longer available, default settings applied."); 
          
//             }
//         }
//         // Add additional Constraints
//         if(supportedConstraints.frameRate && this.headerVariableService.maxFrameRate != "") {
//             spdOptions.sessionDescriptionHandlerOptions.constraints.video["frameRate"] = this.headerVariableService.maxFrameRate;
//         }
//         if(supportedConstraints.height && this.headerVariableService.videoHeight != "") {
//             spdOptions.sessionDescriptionHandlerOptions.constraints.video["height"] = this.headerVariableService.videoHeight;
//         }
//         if(supportedConstraints.aspectRatio && this.headerVariableService.videoAspectRatio != "") {
//             spdOptions.sessionDescriptionHandlerOptions.constraints.video["aspectRatio"] = this.headerVariableService.videoAspectRatio;
//         }
      
//         // Save Devices
//         session.data.withvideo = true;
//         session.data.VideoSourceDevice = this.headerVariableService.currentVideoStringValue;
//         session.data.AudioSourceDevice = this.headerVariableService.currentMicStringValue;
//         session.data.AudioOutputDevice = this.headerVariableService.currentSpeakerStringValue;
      
//         if(this.headerVariableService.startVideoFullScreen) //this.expandVideoArea(lineObj.LineNumber);
      
//         // Send Answer
//         session.accept(spdOptions).then(()=>{
//           this.onInviteAccepted('',session,true);
//         }).catch((error:any)=>{
//             console.warn("Failed to answer call", error, session);
//             session.data.reasonCode = 500;
//             session.data.reasonText = "Client Error";
//             this.teardownSession(session);
//         });
//       }
      
//       rejectCall(sessionData:any) {
//         //console.log("I am in rejectCall");
//         let session = sessionData;
//         if (session == null) {
//             console.warn("Reject failed, null session");
//           this.showDialoge('Error','activity-outline','danger', this.lang.call_failed); 
//         }

        
//         if(session.state == SessionState.Established){
//             session.bye().catch((e:any)=>{
//                 console.warn("Problem in rejectCall(), could not bye() call", e, session);
//             });
//         }
//         else {
//             session.reject({ 
//                 statusCode: 486, 
//                 reasonPhrase: "Busy Here" 
//             }).catch((e:any)=>{
//                 console.warn("Problem in rejectCall(), could not reject() call", e, session);
//                 this.showDialoge('Error','activity-outline','danger', e);
//             });
//         }
//       //   $("#line-" + lineObj.LineNumber + "-msg").html(this.lang.call_rejected);
      
//         session.data.terminateby = "us";
//         session.data.reasonCode = 486;
//         session.data.reasonText = "Busy Here";
//         this.teardownSession(session);
//       }


//       // General Session delegates
//       onSessionReceivedBye(sessionData: any, response: any){
//         //console.log("I am in onSessionReceivedBye");
//         //console.log("Call ended, bye!");
//         sessionData.data.terminateby = "them";
//         sessionData.data.reasonCode = 16;
//         sessionData.data.reasonText = "Normal Call clearing";
//         response.accept(); // Send OK
//         this.teardownSession(sessionData);
//       }

//       onSessionReinvited(sessionData: any, response: any){
//         //console.log("I am in onSessionReinvited");
//         // This may be used to include video streams
//         let sdp = response.body;
//         let session = sessionData;
//         // All the possible streams will get 
//         // Note, this will probably happen after the streams are added
//         session.data.videoChannelNames = [];
//         let videoSections = sdp.split("m=video");
//         if(videoSections.length >= 1){
//             for(let m=0; m<videoSections.length; m++){
//                 if(videoSections[m].indexOf("a=mid:") > -1 && videoSections[m].indexOf("a=label:") > -1){
//                     // We have a label for the media
//                     let lines = videoSections[m].split("\r\n");
//                     let channel = "";
//                     let mid = "";
//                     for(let i=0; i<lines.length; i++){
//                         if(lines[i].indexOf("a=label:") == 0) {
//                             channel = lines[i].replace("a=label:", "");
//                         }
//                         if(lines[i].indexOf("a=mid:") == 0){
//                             mid = lines[i].replace("a=mid:", "");
//                         }
//                     }
//                     session.data.videoChannelNames.push({"mid" : mid, "channel" : channel });
//                 }
//             }
//             //console.log("videoChannelNames:", session.data.videoChannelNames);
//             this.redrawStage(session, false);
//         }
//       }

//       onSessionReceivedMessage(sessionData:any, response:any){
//         //console.log("I am in onSessionReceivedMessage");
//         let messageType = (response.request.headers["Content-Type"].length >=1)? response.request.headers["Content-Type"][0].parsed : "Unknown" ;
//         if(messageType.indexOf("application/x-asterisk-confbridge-event") > -1){
//             // Conference Events JSON
//             let msgJson = JSON.parse(response.request.body);

//             let session = sessionData;
//             if(!session.data.ConfbridgeChannels) session.data.ConfbridgeChannels = [];
//             if(!session.data.ConfbridgeEvents) session.data.ConfbridgeEvents = [];

//             if(msgJson.type == "ConfbridgeStart"){
//                 //console.log("ConfbridgeStart!");
//             }
//             else if(msgJson.type == "ConfbridgeWelcome"){
//                 //console.log("Welcome to the Asterisk Conference");
//                 //console.log("Bridge ID:", msgJson.bridge.id);
//                 //console.log("Bridge Name:", msgJson.bridge.name);
//                 //console.log("Created at:", msgJson.bridge.creationtime);
//                 //console.log("Video Mode:", msgJson.bridge.video_mode);

//                 session.data.ConfbridgeChannels = msgJson.channels; // Write over this
//                 session.data.ConfbridgeChannels.forEach((chan:any)=> {
//                     // The mute and unmute status doesn't appear to be a realtime state, only what the 
//                     // startmuted= setting of the default profile is.
//                     //console.log(chan.caller.name, "Is in the conference. Muted:", chan.muted, "Admin:", chan.admin);
//                 });
//             }
//             else if(msgJson.type == "ConfbridgeJoin"){
//                 msgJson.channels.forEach((chan:any)=> {
//                     let found = false;
//                     session.data.ConfbridgeChannels.forEach((existingChan:any)=> {
//                         if(existingChan.id == chan.id) found = true;
//                     });
//                     if(!found){
//                         session.data.ConfbridgeChannels.push(chan);
//                         session.data.ConfbridgeEvents.push({ event: chan.caller.name + " ("+ chan.caller.number +") joined the conference", eventTime: this.utcDateNow() });
//                         //console.log(chan.caller.name, "Joined the conference. Muted: ", chan.muted);
//                     }
//                 });
//             }
//             else if(msgJson.type == "ConfbridgeLeave"){
//                 msgJson.channels.forEach((chan:any)=> {
//                     session.data.ConfbridgeChannels.forEach((existingChan:any, i:any)=> {
//                         if(existingChan.id == chan.id){
//                             session.data.ConfbridgeChannels.splice(i, 1);
//                             //console.log(chan.caller.name, "Left the conference");
//                             session.data.ConfbridgeEvents.push({ event: chan.caller.name + " ("+ chan.caller.number +") left the conference", eventTime: this.utcDateNow() });
//                         }
//                     });
//                 });
//             }
//             else if(msgJson.type == "ConfbridgeTalking"){
//                 let videoContainer :any= this.headerVariableService.videoContainer;
//                 if(videoContainer){
//                     msgJson.channels.forEach((chan:any)=> {
//                         videoContainer.find('video').each(()=> {
//                             if(this.headerVariableService.videoObject.channel && this.headerVariableService.videoObject.channel == chan.id) {
//                                 if(chan.talking_status == "on"){
//                                     //console.log(chan.caller.name, "is talking.");
//                                     this.headerVariableService.videoObject.isTalking = true;
//                                     // $(this).css("border","1px solid red");
//                                 }
//                                 else {
//                                     //console.log(chan.caller.name, "stopped talking.");
//                                     this.headerVariableService.videoObject.isTalking = false;
//                                     // $(this).css("border","1px solid transparent");
//                                 }
//                             }
//                         });
//                     });
//                 }
//             }
//             else if(msgJson.type == "ConfbridgeMute"){
//                 msgJson.channels.forEach((chan:any)=> {
//                     session.data.ConfbridgeChannels.forEach((existingChan:any)=> {
//                         if(existingChan.id == chan.id){
//                             //console.log(existingChan.caller.name, "is now muted");
//                             existingChan.muted = true;
//                         }
//                     });
//                 });
//                 this.redrawStage(session, false);
//             }
//             else if(msgJson.type == "ConfbridgeUnmute"){
//                 msgJson.channels.forEach((chan:any)=> {
//                     session.data.ConfbridgeChannels.forEach((existingChan:any)=> {
//                         if(existingChan.id == chan.id){
//                             //console.log(existingChan.caller.name, "is now unmuted");
//                             existingChan.muted = false;
//                         }
//                     });
//                 });
//                 this.redrawStage(session, false);
//             }
//             else if(msgJson.type == "ConfbridgeEnd"){
//                 //console.log("The Asterisk Conference has ended, bye!");
//             }
//             else {
//                 console.warn("Unknown Asterisk Conference Event:", msgJson.type, msgJson);
//             }
//             // RefreshLineActivity(lineObj.LineNumber);
//             response.accept();
//         } 
//         else if(messageType.indexOf("application/x-myphone-confbridge-chat") > -1){
//             //console.log("x-myphone-confbridge-chat", response);


//             response.accept();
//         }
//         else {
//             console.warn("Unknown message type")
//             response.reject();
//         }
//       }

//       onSessionDescriptionHandlerCreated(sessionData:any, sdh:any, provisional:any, includeVideo:any){
//         //console.log("I am in onSessionDescriptionHandlerCreated");

//         if (sdh) {
//             if(sdh.peerConnection){
//                 //console.log(sdh);
//                 sdh.peerConnection.ontrack = (event:any)=>{
//                      //console.log(event);
//                     this.onTrackAddedEvent(sessionData, includeVideo);
//                 }
//                 // sdh.peerConnectionDelegate = {
//                 //     ontrack: (event:any)=>{
//                 //         //console.log(event);
//                 //         onTrackAddedEvent(sessionData, includeVideo);
//                 //     }
//                 // }
//             }
//             else{
//                 console.warn("onSessionDescriptionHandler fired without a peerConnection");
//             }
//         }
//         else{
//             console.warn("onSessionDescriptionHandler fired without a sessionDescriptionHandler");
//         }
//       }
      
//       onTrackAddedEvent(sessionData:any, includeVideo:any){
//         //console.log("I am in onTrackAddedEvent");
//         // Gets remote tracks
//         let session = sessionData;
//         // TODO: look at detecting video, so that UI switches to audio/video automatically.

//         let pc = session.sessionDescriptionHandler.peerConnection;
//         //console.log("Peer connection from session : ",pc);

//         this.headerVariableService.remoteAudioStream = new MediaStream();
//         //console.log("Ceated audio stream");        
//         this.headerVariableService.remoteVideoStream = new MediaStream();
//         //console.log("Ceated video stream");  

//         pc.getTransceivers().forEach( (transceiver:any, i:number)=> {

//             //console.log("Got transceiver at index : ",i); 

//             // Add Media
//             let receiver = transceiver.receiver;
//             //console.log("Attaching media"); 
//             //console.log("Receiver : ",receiver); 

//             if(receiver.track){

//                 //console.log("Receiver Track : ",receiver.track); 

//                 //console.log("Receiver Track Kind: ",receiver.track.kind);

//                 if(receiver.track.kind == "audio"){
//                     //console.log("Adding Remote Audio Track");
//                     this.headerVariableService.remoteAudioStream.addTrack(receiver.track);
//                 }
//                 if(includeVideo && receiver.track.kind == "video"){
//                     if(transceiver.mid){
//                         receiver.track.mid = transceiver.mid;
//                         //console.log("Adding Remote Video Track - ", receiver.track.readyState , "MID:", receiver.track.mid);
//                         this.headerVariableService.remoteVideoStream.addTrack(receiver.track);
//                     }
//                 }
//             }
//         });

//         // Attach Audio
//         //console.log("Attaching audio media to speaker"); 
//         //console.log("this.headerVariableService.remoteAudi : ",this.headerVariableService.remoteAudio); 
//         //console.log("remoteAudioStream.getAudioTracks().length", this.headerVariableService.remoteAudioStream.getAudioTracks().length); 

//         if(this.headerVariableService.remoteAudioStream.getAudioTracks().length >= 1){
//             //console.log("Setting tracks audio html tag");
//             let remoteAudio = this.headerVariableService.remoteAudio;
//             //console.log("Attaching stream to object");
//             remoteAudio.srcObject = this.headerVariableService.remoteAudioStream;
//             remoteAudio.onloadedmetadata = (e:any)=> {
//                 //console.log("Media loaded to remote audio");
//                 //console.log("remoteAudio.sinkId", remoteAudio.sinkId);
//                 if (typeof remoteAudio.sinkId !== 'undefined') {
//                     //console.log("Setting new Sink ID");
//                     remoteAudio.setSinkId(this.headerVariableService.currentSpeakerStringValue).then(()=>{
//                         //console.log("sinkId applied: "+ this.headerVariableService.currentSpeakerStringValue);
//                     }).catch((e:any)=>{
//                         console.warn("Error using setSinkId: ", e);
//                     });
//                 }
//                 //console.log("Playing Audio");
//                 remoteAudio.play();
//             }
//         }

//         // if(includeVideo){
//            //This code is written in video Dialog Coponent
//         // }
//       }

//         // Session Events
//         // ==============
//         // Incoming INVITE
//       onInviteCancel(session:any, response:any){
//         //console.log("I am in onInviteCancel");
//           // Remote Party Canceled while ringing...

//           // Check to see if this call has been completed elsewhere
//           // https://github.com/InnovateAsterisk/Browser-Phone/issues/405
//           let temp_cause = 0;
//           let reason = response.headers["Reason"];

//           //console.log("Invite cancel reason : ", reason);

//           if (reason !== undefined && reason.length > 0){
//               for (let i = 0; i < reason.length; i++){
//                   let cause = reason[i].raw.toLowerCase().trim(); // Reason: Q.850 ;cause=16 ;text="Terminated"
//                   let items = cause.split(';');
//                   if (items.length >= 2 && (items[0].trim() == "sip" || items[0].trim() == "q.850") && items[1].includes("cause") && cause.includes("call completed elsewhere")){
//                       temp_cause = parseInt(items[1].substring(items[1].indexOf("=")+1).trim());
//                       // No sample provided for "token"
//                       //console.log("Changing temp case to what it should be  : ",temp_cause);
//                       break;
//                   }
//               }
//           }

//           session.data.terminateby = "them";
//           session.data.reasonCode = temp_cause;

//           //console.log("Invite cancel reason is set into session via temp cause : ",temp_cause);

//           if(temp_cause == 0){
//               session.data.reasonText = "Call Cancelled";
//               //console.log("Call canceled by remote party before answer");
//           } else {
//               session.data.reasonText = "Call completed elsewhere";
//               //console.log("Call completed elsewhere before answer");
//           }

//           session.dispose().catch((error:any)=>{
//               //console.log("Failed to dispose the cancel dialog", error);
//           })

//           this.teardownSession(session);
//       }


//       // Both Incoming and outgoing INVITE
//       onInviteAccepted(sessionData:any, includeVideo:any, response:any){
//       //console.log("I am in onInviteAccepted");

      
//       this.headerVariableService.callInProgress = true;
//       this.headerVariableService.callStatus = "success";
//       this.currentConnectedSessionData = sessionData;
//       this.headerVariableService.isVideoCall = includeVideo;

//       // Call in progress
//       let session = sessionData;

//       //console.log("Pausing music if not yet paused");

//       if(session.data.earlyMedia){
//           session.data.earlyMedia.pause();
//           session.data.earlyMedia.removeAttribute('src');
//           session.data.earlyMedia.load();
//           session.data.earlyMedia = null;
//       }

//       window.clearInterval(session.data.callTimer);
//     //   window.clearInterval(this.headerVariableService.timer);

//       //console.log("Call has started , setting initial value for session.data.callTimer variable : ",session.data.callTimer);

//       let startTime = moment.utc();
//       session.data.startTime = startTime;

//       session.data.callTimer = window.setInterval(()=>{
//           let now = moment.utc();
//           let duration = moment.duration(now.diff(startTime));
//           let timeStr = this.formatShortDuration(duration.asSeconds());
//           this.headerVariableService.timer = timeStr;
//           //console.log("Call Timer as function is called : ",now, duration, timeStr);
//       }, 1000);


//       session.isOnHold = false;
//       session.data.started = true;

//       //console.log("Session data started inside Accept");

//       if(includeVideo){
//           //console.log("Viedo is included in this scenario");
//           // Preview our stream from peer connection
//           let localVideoStream = new MediaStream();
//           let pc = session.sessionDescriptionHandler.peerConnection;
//           pc.getSenders().forEach((sender:any) =>{
//               if(sender.track && sender.track.kind == "video"){
//                   localVideoStream.addTrack(sender.track);
//               }
//           });

//          let localVideo = this.headerVariableService.localVideo;
//           localVideo.srcObject = localVideoStream;
//           localVideo.onloadedmetadata = (e:any)=> {
//               localVideo.play();
//           }

//           // Apply Call Bandwidth Limits
//           if(this.headerVariableService.maxVideoBandwidth > -1){
//               pc.getSenders().forEach((sender:any)=> {
//                   if(sender.track && sender.track.kind == "video"){

//                       let parameters = sender.getParameters();
//                       if(!parameters.encodings) parameters.encodings = [{}];
//                       parameters.encodings[0].maxBitrate =  0 //'this.maxVideoBandwidth' * 1000;

//                       //console.log("Applying limit for Bandwidth to: ", this.headerVariableService.maxVideoBandwidth + "kb per second")

//                       // Only going to try without re-negotiations
//                       sender.setParameters(parameters).catch((e:any)=>{
//                           console.warn("Cannot apply Bandwidth Limits", e);
//                       });

//                   }
//               });
//           }
//       }

//       // Start Call Recording
//       if(this.headerVariableService.recordAllCalls) {
//         //console.log("Record all call is true , hence starting call recording");
//         this.startRecording(session);
//       }

//       if(includeVideo && this.headerVariableService.startVideoFullScreen)
//             {
//                  //this.expandVideoArea(lineObj.LineNumber);
//                  //console.log("Start video full screen is turned on");
//             }
//       }

//       // General end of Session
//       teardownSession(sessionData:any) {
//         //console.log("I am in teardownSession");
//         this.headerVariableService.callRinging = false;
//         this.headerVariableService.callInProgress = false;
//         this.headerVariableService.callStatus = 'danger';
//         this.currentConnectedSessionData = null;
//         this.incommingCallSessionData = null;
//         this.headerVariableService.isVideoCall = false;
        
//         if(sessionData == null) return;

//         let session = sessionData;
//         if(session.data.teardownComplete == true) return;
//         session.data.teardownComplete = true; // Run this code only once

//         // // Call UI
//         // if(session.data.earlyReject != true){
//         //     //HidePopup();
//         // }

//         // End any child calls
//         if(session.data.childsession){
//             session.data.childsession.dispose().then(()=>{
//                 session.data.childsession = null;
//             }).catch((error:any)=>{
//                 session.data.childsession = null;
//                 // Suppress message
//             });
//         }

//         // Mixed Tracks
//         if(session.data.AudioSourceTrack && session.data.AudioSourceTrack.kind == "audio"){
//             session.data.AudioSourceTrack.stop();
//             session.data.AudioSourceTrack = null;
//         }
//         // Stop any Early Media
//         if(session.data.earlyMedia){
//             session.data.earlyMedia.pause();
//             session.data.earlyMedia.removeAttribute('src');
//             session.data.earlyMedia.load();
//             session.data.earlyMedia = null;
//         }
//         // Stop any ringing calls
//         if(session.data.ringerObj){
//             session.data.ringerObj.pause();
//             session.data.ringerObj.removeAttribute('src');
//             session.data.ringerObj.load();
//             session.data.ringerObj = null;
//         }
        
//         // Stop Recording if we are
//         this.stopRecording(session);

//         // Make sure you have released the microphone
//         if(session && session.sessionDescriptionHandler && session.sessionDescriptionHandler.peerConnection){
//             let pc = session.sessionDescriptionHandler.peerConnection;
//             pc.getSenders().forEach( (RTCRtpSender:any) =>{
//                 if(RTCRtpSender.track && RTCRtpSender.track.kind == "audio") {
//                     RTCRtpSender.track.stop();
//                 }
//             });
//         }

//         // End timers
//         window.clearInterval(session.data.videoResampleInterval);
//         window.clearInterval(session.data.callTimer);



//         // Check if this call was missed
//         if (session.data.calldirection == "inbound"){
//             if(session.data.earlyReject){
//                 // Call was rejected without even ringing
//             } else if (session.data.terminateby == "them" && session.data.startTime == null){
//                 // Call Terminated by them during ringing
//                 if(session.data.reasonCode == 0){
//                     // Call was canceled, and not answered elsewhere 
//                 }
//             }
//         }
//       }


//       startRecording(sessionData:any){
//         //console.log("I am in startRecording");
//         let session = sessionData;
//         if(session == null){
//             console.warn("Could not find session");
//             return;
//         }
      
//         let id = this.uID();
      
//         if(!session.data.recordings) session.data.recordings = [];
//         session.data.recordings.push({
//             uID: id,
//             startTime: this.utcDateNow(),
//             stopTime: this.utcDateNow(),
//         });
      
//         if(session.data.mediaRecorder && session.data.mediaRecorder.state == "recording"){
//             console.warn("Call Recording was somehow on... stopping call recording");
//             this.stopRecording(session);
//             // State should be inactive now, but the data available event will fire
//             // Note: potential race condition here if someone hits the stop, and start quite quickly.
//         }
//         //console.log("Creating call recorder...");
      
//         session.data.recordingAudioStreams = new MediaStream();
//         let pc = session.sessionDescriptionHandler.peerConnection;
//         pc.getSenders().forEach((RTCRtpSender:any) =>{
//             if(RTCRtpSender.track && RTCRtpSender.track.kind == "audio") {
//                 //console.log("Adding sender audio track to record:", RTCRtpSender.track.label);
//                 session.data.recordingAudioStreams.addTrack(RTCRtpSender.track);
//             }
//         });
//         pc.getReceivers().forEach((RTCRtpReceiver:any)=> {
//             if(RTCRtpReceiver.track && RTCRtpReceiver.track.kind == "audio") {
//                 //console.log("Adding receiver audio track to record:", RTCRtpReceiver.track.label);
//                 session.data.recordingAudioStreams.addTrack(RTCRtpReceiver.track);
//             }
//         });
      
//         // Resample the Video Recording
//         if(session.data.withvideo){
//             let recordingWidth = 640;
//             let recordingHeight = 360;
//             let pnpVideSize = 100;
//             if(this.headerVariableService.recordingVideoSize == "HD"){
//                 recordingWidth = 1280;
//                 recordingHeight = 720;
//                 pnpVideSize = 144;
//             }
//             if(this.headerVariableService.recordingVideoSize == "FHD"){
//                 recordingWidth = 1920;
//                 recordingHeight = 1080;
//                 pnpVideSize = 240;
//             }

//             // Create Canvas
//             session.data.recordingCanvas =this.headerVariableService.recordingCanvas;
//             session.data.recordingCanvas.width = (this.headerVariableService.recordingLayout == "side-by-side")? (recordingWidth * 2) + 5: recordingWidth;
//             session.data.recordingCanvas.height = recordingHeight;
//             session.data.recordingContext = session.data.recordingCanvas.getContext("2d");
      
//             // Capture Interval
//             window.clearInterval(session.data.recordingRedrawInterval);
//             session.data.recordingRedrawInterval = window.setInterval(()=>{
      
//                 // Video Source
//                 let pnpVideo = this.headerVariableService.localVideo;
      
//                 let mainVideo = null;
//                 let validVideos = [];
//                 let talkingVideos = [];
//                 let videoContainer:any = this.headerVariableService.videoContainer;
//                 let potentialVideos =  videoContainer.find('video').length;
//                 if(potentialVideos == 0){
//                     // Nothing to render
//                      //console.log("Nothing to render in this frame")
//                 }
//                 else if (potentialVideos == 1){
//                     mainVideo = videoContainer.find('video')[0];
//                     //console.log("Only one video element", mainVideo);
//                 }
//                 else if (potentialVideos > 1){
//                     // Decide what video to record
//                     videoContainer.find('video').each((video:any,i:any)=> {
//                         let videoTrack = video.srcObject.getVideoTracks()[0];
//                         if(videoTrack.readyState == "live" && video.videoWidth > 10 && video.videoHeight >= 10) {
//                             if(video.srcObject.isPinned == true){
//                                 mainVideo = video;
//                                 //console.log("Multiple Videos using last PINNED frame");
//                             }
//                             if(video.srcObject.isTalking == true){
//                                 talkingVideos.push(video);
//                             }
//                             validVideos.push(video);
//                         }
//                     });
      
//                     // Check if we found something
//                     if(mainVideo == null && talkingVideos.length >= 1){
//                         // Nothing pinned use talking
//                         mainVideo = talkingVideos[0];
//                         //console.log("Multiple Videos using first talking frame");
//                     }
//                     if(mainVideo == null && validVideos.length >= 1){
//                         // Nothing pinned or talking use valid
//                         mainVideo = validVideos[0];
//                         //console.log("Multiple Videos using first VALID frame");
//                     }
//                 }
      
//                 // Main Video
//                 let videoWidth = (mainVideo && mainVideo.videoWidth > 0)? mainVideo.videoWidth : recordingWidth ;
//                 let videoHeight = (mainVideo && mainVideo.videoHeight > 0)? mainVideo.videoHeight : recordingHeight ;
//                 if(videoWidth >= videoHeight){
//                     // Landscape / Square
//                     let scale = recordingWidth / videoWidth;
//                     videoWidth = recordingWidth;
//                     videoHeight = videoHeight * scale;
//                     if(videoHeight > recordingHeight){
//                         let scale = recordingHeight / videoHeight;
//                         videoHeight = recordingHeight;
//                         videoWidth = videoWidth * scale;
//                     }
//                 } 
//                 else {
//                     // Portrait
//                     let scale = recordingHeight / videoHeight;
//                     videoHeight = recordingHeight;
//                     videoWidth = videoWidth * scale;
//                 }
//                 let offsetX = (videoWidth < recordingWidth)? (recordingWidth - videoWidth) / 2 : 0;
//                 let offsetY = (videoHeight < recordingHeight)? (recordingHeight - videoHeight) / 2 : 0;
//                 if(this.headerVariableService.recordingLayout == "side-by-side") offsetX = recordingWidth + 5 + offsetX;
      
//                 // Picture-in-Picture Video
//                 let pnpVideoHeight = pnpVideo.videoHeight;
//                 let pnpVideoWidth = pnpVideo.videoWidth;
//                 // let pnpVideoHeight = 50;
//                 // let pnpVideoWidth = 70;
//                 if(pnpVideoHeight > 0){
//                     if(pnpVideoWidth >= pnpVideoHeight){
//                         let scale = pnpVideSize / pnpVideoHeight;
//                         pnpVideoHeight = pnpVideSize;
//                         pnpVideoWidth = pnpVideoWidth * scale;
//                     } 
//                     else{
//                         let scale = pnpVideSize / pnpVideoWidth;
//                         pnpVideoWidth = pnpVideSize;
//                         pnpVideoHeight = pnpVideoHeight * scale;
//                     }
//                 }
//                 let pnpOffsetX = 10;
//                 let pnpOffsetY = 10;
//                 if(this.headerVariableService.recordingLayout == "side-by-side"){
//                     pnpVideoWidth = pnpVideo.videoWidth;
//                     pnpVideoHeight = pnpVideo.videoHeight;
//                 //   let pnpVideoHeight = 50;
//                 //   let pnpVideoWidth = 70;
//                     if(pnpVideoWidth >= pnpVideoHeight){
//                         // Landscape / Square
//                         let scale = recordingWidth / pnpVideoWidth;
//                         pnpVideoWidth = recordingWidth;
//                         pnpVideoHeight = pnpVideoHeight * scale;
//                         if(pnpVideoHeight > recordingHeight){
//                             let scale = recordingHeight / pnpVideoHeight;
//                             pnpVideoHeight = recordingHeight;
//                             pnpVideoWidth = pnpVideoWidth * scale;
//                         }
//                     } 
//                     else {
//                         // Portrait
//                         let scale = recordingHeight / pnpVideoHeight;
//                         pnpVideoHeight = recordingHeight;
//                         pnpVideoWidth = pnpVideoWidth * scale;
//                     }
//                     pnpOffsetX = (pnpVideoWidth < recordingWidth)? (recordingWidth - pnpVideoWidth) / 2 : 0;
//                     pnpOffsetY = (pnpVideoHeight < recordingHeight)? (recordingHeight - pnpVideoHeight) / 2 : 0;
//                 }
      
//                 // Draw Background
//                 session.data.recordingContext.fillRect(0, 0, session.data.recordingCanvas.width, session.data.recordingCanvas.height);
      
//                 // Draw Main Video
//                 if(mainVideo && mainVideo.videoHeight > 0){
//                     session.data.recordingContext.drawImage(mainVideo, offsetX, offsetY, videoWidth, videoHeight);
//                 }
      
//                 // Draw PnP
//                 if(pnpVideo.videoHeight > 0 && (this.headerVariableService.recordingLayout == "side-by-side" || this.headerVariableService.recordingLayout == "them-pnp")){
//                     // Only Draw the Pnp Video when needed
//                     session.data.recordingContext.drawImage(pnpVideo, pnpOffsetX, pnpOffsetY, pnpVideoWidth, pnpVideoHeight);
//                 }
//             }, Math.floor(1000/this.headerVariableService.recordingVideoFps));
      
//             // Start Video Capture
//             session.data.recordingVideoMediaStream = session.data.recordingCanvas.captureStream(this.headerVariableService.recordingVideoFps);
//         }
      
//         session.data.recordingMixedAudioVideoRecordStream = new MediaStream();
//         session.data.recordingMixedAudioVideoRecordStream.addTrack(this.mixAudioStreams(session.data.recordingAudioStreams).getAudioTracks()[0]);
//         if(session.data.withvideo){
//             session.data.recordingMixedAudioVideoRecordStream.addTrack(session.data.recordingVideoMediaStream.getVideoTracks()[0]);
//         }
      
//         let mediaType = "audio/webm"; // audio/mp4 | audio/webm;
//         if(session.data.withvideo) mediaType = "video/webm";
//         let options = {
//             mimeType : mediaType
//         }
//         // Note: It appears that mimeType is optional, but... Safari is truly dreadful at recording in mp4, and doesn't have webm yet
//         // You you can leave this as default, or force webm, however know that Safari will be no good at this either way.
//         // session.data.mediaRecorder = new MediaRecorder(session.data.recordingMixedAudioVideoRecordStream, options);
//         session.data.mediaRecorder = new MediaRecorder(session.data.recordingMixedAudioVideoRecordStream);
//         session.data.mediaRecorder.data = {}
//         session.data.mediaRecorder.data.id = ""+ id;
//         session.data.mediaRecorder.data.sessionId = ""+ session.id;
//         session.data.mediaRecorder.ondataavailable = (event:any)=> {
//             //console.log("Got Call Recording Data: ", event.data.size +"Bytes", 'this.data.id', 'this.data.buddyId', 'this.data.sessionId');
//             // Save the Audio/Video file
//             this.saveCallRecording(event.data, 'this.data.id', 'this.data.buddyId', 'this.data.sessionId');
//         }
      
//         //console.log("Starting Call Recording", id);
//         session.data.mediaRecorder.start(); // Safari does not support time slice
//         session.data.recordings[session.data.recordings.length-1].startTime = this.utcDateNow();
      
//       //   $("#line-" + lineObj.LineNumber + "-msg").html(this.lang.call_recording_started);
      
//        // this.updatelinescroll(lineNum);
//       }

      
//       saveCallRecording(blob:any, id:any, buddy:any, sessionid:any){
//         //console.log("I am in saveCallRecording");
//         let indexedDB = window.indexedDB;
//         let request = indexedDB.open("CallRecordings", 1);
//         request.onerror = (event:any)=> {
//             console.error("IndexDB Request Error:", event);
//         }
//         request.onupgradeneeded = (event:any)=> {
//             console.warn("Upgrade Required for IndexDB... probably because of first time use.");
//             let IDB = request.result;
      
//           //   // Create Object Store
//             if(IDB.objectStoreNames.contains("Recordings") == false){
//                 let objectStore = IDB.createObjectStore("Recordings", { keyPath: "uID" });
//                 objectStore.createIndex("sessionid", "sessionid", { unique: false });
//                 objectStore.createIndex("bytes", "bytes", { unique: false });
//                 objectStore.createIndex("type", "type", { unique: false });
//                 objectStore.createIndex("mediaBlob", "mediaBlob", { unique: false });
//             }
//             else {
//                 console.warn("IndexDB requested upgrade, but object store was in place.");
//             }
//         }
//         request.onsuccess = (event:any)=> {
//             //console.log("IndexDB connected to CallRecordings");
      
//             let IDB = request.result;
//             if(IDB.objectStoreNames.contains("Recordings") == false){
//                 console.warn("IndexDB CallRecordings.Recordings does not exists, this call recoding will not be saved.");
//                 IDB.close();
//                 window.indexedDB.deleteDatabase("CallRecordings"); // This should help if the table structure has not been created.
//                 return;
//             }
//             IDB.onerror = (event:any)=> {
//                 console.error("IndexDB Error:", event);
//             }
        
//             // Prepare data to write
//             let data = {
//                 uID: id,
//                 sessionid: sessionid,
//                 bytes: blob.size,
//                 type: blob.type,
//                 mediaBlob: blob
//             }
//             // Commit Transaction
//             let transaction = IDB.transaction(["Recordings"], "readwrite");
//             let objectStoreAdd = transaction.objectStore("Recordings").add(data);
//             objectStoreAdd.onsuccess = (event:any)=> {
//                 //console.log("Call Recording Success: ", id, blob.size, blob.type, buddy, sessionid);
//             }
//         }
//       }
      
      
//       stopRecording(sessionData:any){
//         //console.log("I am in stopRecording");
//         let session = sessionData;
//         // Called at the end of a call

//         if(session.data.mediaRecorder){
//             if(session.data.mediaRecorder.state == "recording"){
//                 //console.log("Stopping Call Recording");
//                 session.data.mediaRecorder.stop();
//                 session.data.recordings[session.data.recordings.length-1].stopTime = this.utcDateNow();
//                 window.clearInterval(session.data.recordingRedrawInterval);
  
//                // $("#line-" + lineObj.LineNumber + "-msg").html(this.lang.call_recording_stopped);
//                // this.updatelinescroll(lineNum);
//             } 
//             else{
//                 console.warn("Recorder is in an unknown state");
//             }
//         }
//         return;
//       }


    
//     // Subscription Events
//     // ===================

//     voicemailNotify(notification:any){

//         //console.log("I am in voicemailNotify");

//         // Messages-Waiting: yes        <-- yes/no
//         // Voice-Message: 1/0           <-- new/old
//         // Voice-Message: 1/0 (0/0)     <-- new/old (ugent new/old)
//         if(notification.request.body.indexOf("Messages-Waiting:") > -1){
//             notification.accept();
    
//             let messagesWaiting = (notification.request.body.indexOf("Messages-Waiting: yes") > -1)
//             let newVoiceMessages = 0;
//             let oldVoiceMessages = 0;
//             let ugentNewVoiceMessage = 0;
//             let ugentOldVoiceMessage = 0;
    
//             if(messagesWaiting){
//                 //console.log("Messages Waiting!");
//                 let lines = notification.request.body.split("\r\n");
//                 for(let l=0; l<lines.length; l++){
//                     if(lines[l].indexOf("Voice-Message: ") > -1){
//                         let value = lines[l].replace("Voice-Message: ", ""); // 1/0 (0/0)
//                         if(value.indexOf(" (") > -1){
//                             // With Ugent options
//                             newVoiceMessages = parseInt(value.split(" (")[0].split("\/")[0]);
//                             oldVoiceMessages = parseInt(value.split(" (")[0].split("\/")[1]);
//                             ugentNewVoiceMessage = parseInt(value.split(" (")[1].replace(")","").split("\/")[0]);
//                             ugentOldVoiceMessage = parseInt(value.split(" (")[1].replace(")","").split("\/")[1]);
//                         } else {
//                             // Without
//                             newVoiceMessages = parseInt(value.split("\/")[0]);
//                             oldVoiceMessages = parseInt(value.split("\/")[1]);
//                         }
//                     }
//                 }
//                 //console.log("Voicemail: ", newVoiceMessages, oldVoiceMessages, ugentNewVoiceMessage, ugentOldVoiceMessage);
    
//                 // Show the messages waiting bubble
//                 //   $("#TxtVoiceMessages").html(""+ newVoiceMessages)
//                 //   $("#TxtVoiceMessages").show();
//                 // ******ADD************
//                 // Show message / voiceMessage on messages header
    
//                 // Show a system notification
//                 // if(newVoiceMessages > this.userAgent.lastVoicemailCount){
//                 //   this.userAgent.lastVoicemailCount = newVoiceMessages;
//                 //     if ("Notification" in window) {
//                 //         if (Notification.permission === "granted") {
    
//                 //             let noticeOptions = { 
//                 //                 body: this.lang.you_have_new_voice_mail.replace("{0}", newVoiceMessages)
//                 //             }
    
//                 //             let vmNotification = new Notification(this.lang.new_voice_mail, noticeOptions);
//                 //             vmNotification.onclick = (event)=> {
//                 //                 if(this.headerVariableService.voicemailDid != ""){
//                 //                   this.dialLine("audio", null, this.headerVariableService.voicemailDid, this.lang.voice_mail,'');
//                 //                 }
//                 //             }
//                 //         }
//                 //     }
//                 // }
    
//             } else {
//                 // Hide the messages waiting bubble
//             //   $("#TxtVoiceMessages").html("0")
//             //   $("#TxtVoiceMessages").hide();
//             }
    
//         }
//         else {
//             // Doesn't seem to be an message notification https://datatracker.ietf.org/doc/html/rfc3842
//             notification.reject();
//         }
//     }


  
//     receiveNotify(notification:any, selfSubscribe:any) {

//     //console.log("I am in receiveNotify");

//     if (this.userAgent == null || !this.userAgent.isRegistered()) return;
  
//     notification.accept();
  
//     let buddy = "";
    
//     let ContentType = notification.request.headers["Content-Type"][0].parsed;
//     if (ContentType == "application/pidf+xml") {
//         // Handle Presence
//         /*
//         // Asterisk chan_sip
//         <?xml version="1.0" encoding="ISO-8859-1"?>
//         <presence
//             xmlns="urn:ietf:params:xml:ns:pidf" 
//             xmlns:pp="urn:ietf:params:xml:ns:pidf:person" 
//             xmlns:es="urn:ietf:params:xml:ns:pidf:rid:status:rid-status"
//             xmlns:ep="urn:ietf:params:xml:ns:pidf:rid:rid-person"
//             entity="sip:webrtc@192.168.88.98">
  
//             <pp:person>
//                 <status>
//                     <ep:activities>
//                         <ep:away/>
//                     </ep:activities>
//                 </status>
//             </pp:person>
  
//             <note>Not online</note>
//             <tuple id="300">
//                 <contact priority="1">sip:300@192.168.88.98</contact>
//                 <status>
//                     <basic>open | closed</basic>
//                 </status>
//             </tuple>
//         </presence>
  
//         // Asterisk chan_pj-sip
//         <?xml version="1.0" encoding="UTF-8"?>
//         <presence 
//             entity="sip:300@192.168.88.40:443;transport=ws" 
//             xmlns="urn:ietf:params:xml:ns:pidf" 
//             xmlns:dm="urn:ietf:params:xml:ns:pidf:data-model" 
//             xmlns:rid="urn:ietf:params:xml:ns:pidf:rid">
//             <note>Ready</note>
//             <tuple id="300">
//                 <status>
//                     <basic>open</basic>
//                 </status>
//                 <contact priority="1">sip:User1@raspberrypi.local</contact>
//             </tuple>
//             <dm:person />
//         </presence>
  
//         // OpenSIPS 
//         <?xml version="1.0"?>
//         <presence 
//             xmlns="urn:ietf:params:xml:ns:pidf" 
//             entity="sip:200@ws-eu-west-1.innovateasterisk.com">
//             <tuple xmlns="urn:ietf:params:xml:ns:pidf" id="tuple_mixing-id">
//                 <status>
//                     <basic>closed</basic>
//                 </status>
//             </tuple>
//         </presence>
  
//         <?xml version="1.0"?>
//         <presence 
//             xmlns="urn:ietf:params:xml:ns:pidf" 
//             entity="sip:TTbXG7XMO@ws-eu-west-1.innovateasterisk.com">
//             <tuple 
//                 xmlns="urn:ietf:params:xml:ns:pidf" 
//                 id="0x7ffe17f496c0">
//                 <status>
//                     <basic>open</basic>
//                 </status>
//             </tuple>
//         </presence>
  
  
//         <?xml version="1.0"?>
//         <presence 
//             xmlns="urn:ietf:params:xml:ns:pidf" 
//             entity="sip:TTbXG7XMO@ws-eu-west-1.innovateasterisk.com">
//             <tuple 
//                 xmlns="urn:ietf:params:xml:ns:pidf" 
//                 id="tuple_mixing-id">
//                 <status>
//                     <basic>open</basic>
//                 </status>
//             </tuple>
//             <note xmlns="urn:ietf:params:xml:ns:pidf">On the phone</note>
//             <dm:person 
//                 xmlns:dm="urn:ietf:params:xml:ns:pidf:data-model" 
//                 xmlns:rid="urn:ietf:params:xml:ns:pidf:rid" 
//                 id="peers_mixing-id">
//                 <rid:activities>
//                     <rid:on-the-phone/>
//                 </rid:activities>
//                 <dm:note>On the phone</dm:note>
//             </dm:person>
//         </presence>
  
//         // There can be more than one tuple
//         <?xml version="1.0"?>
//         <presence 
//             xmlns="urn:ietf:params:xml:ns:pidf" 
//             entity="sip:TTbXG7XMO@ws-eu-west-1.innovateasterisk.com">
//             <tuple 
//                 xmlns="urn:ietf:params:xml:ns:pidf" 
//                 id="0x7ffce2b4b1a0">
//                 <status>
//                     <basic>open</basic>
//                 </status>
//             </tuple>
//             <tuple 
//                 xmlns="urn:ietf:params:xml:ns:pidf"
//                 id="0x7ffd6abd4a40">
//                 <status>
//                     <basic>open</basic>
//                 </status>
//             </tuple>
//         </presence>
//   "
  
  
//   open: In the context of INSTANT MESSAGES, this value means that the
//     associated <contact> element, if any, corresponds to an INSTANT
//     INBOX that is ready to accept an INSTANT MESSAGE.
  
//   closed: In the context of INSTANT MESSAGES, this value means that
//     the associated <contact> element, if any, corresponds to an
//     INSTANT INBOX that is unable to accept an INSTANT MESSAGE.
  
//         */
  
//         let parser = new XMLParser();
//         let xml:any = parser.parse(notification.request.body);
//         const builder = new XMLBuilder();
//         const xmlContent = builder.build(xml);

//         // The value of the 'entity' attribute is the 'pres' URL of the PRESENT publishing this presence document.
//         // (In some cases this can present as the user... what if using DIDs)
//         let ObservedUser = xml.find("presence").attr("entity");
//         buddy = ObservedUser.split("@")[0].split(":")[1];
//         // buddy = xml.find("presence").find("tuple").attr("id"); // Asterisk does this, but its not correct.
//         // buddy = notification.request.from.uri.user; // Unreliable 
  
//         let availability = "closed"
//         // availability = xml.find("presence").find("tuple").find("status").find("basic").text();
//         let tuples = xml.find("presence").find("tuple");
//         if(tuples){
//             tuples.forEach((obj:any,i:any)=>{
//                 // So if any of the contacts are open, then say open
//                 // if($(obj).find("status").find("basic").text() == "open") {
//                 //     availability = "open";
//                 // }

//                 //Write code to change current user presense

//             });
//         }
  
//         this.headerVariableService.selfPresence =  xml.find("presence").find("note").text(); 
//         if(this.headerVariableService.selfPresence == ""){
//             if (availability == "open") this.headerVariableService.selfPresence =  "Ready";
//             if (availability == "closed") this.headerVariableService.selfPresence =  "Not online";
//         }
//     }
//     else if (ContentType == "application/dialog-info+xml") {
//         // Handle "Dialog" State
//         let parser = new XMLParser();
//         let xml:any = parser.parse(notification.request.body);
//         const builder = new XMLBuilder();
//         const xmlContent = builder.build(xml);

//         /*
//         Asterisk:
//         <?xml version="1.0"?>
//         <dialog-info 
//             xmlns="urn:ietf:params:xml:ns:dialog-info" 
//             version="0-99999" 
//             state="full|partial" 
//             entity="sip:xxxx@XXX.XX.XX.XX">
//             <dialog id="xxxx">
//                 <state>trying | proceeding | early | terminated | confirmed</state>
//             </dialog>
//         </dialog-info>
  
//         OpenSIPS:
//         <?xml version="1.0"?>
//         <dialog-info 
//             xmlns="urn:ietf:params:xml:ns:dialog-info" 
//             version="18" 
//             state="full" 
//             entity="sip:TTbXG7XMO@ws-eu-west-1.innovateasterisk.com"
//         />
  
//         <?xml version="1.0"?>
//         <dialog-info 
//             xmlns="urn:ietf:params:xml:ns:dialog-info" 
//             version="17" 
//             entity="sip:TTbXG7XMO@ws-eu-west-1.innovateasterisk.com" 
//             state="partial">
//             <dialog 
//                 id="soe2vr886cbn1ccj3h.0" 
//     *           local-tag="ceq735vrh" 
//     *           remote-tag="a1d22259-28ea-434f-9680-b925218b7418" 
//                 direction="initiator">
//                 <state>terminated</state>
//     *           <remote>
//                     <identity display="Bob">sip:*65@ws-eu-west-1.innovateasterisk.com</identity>
//                     <target uri="sip:*65@ws-eu-west-1.innovateasterisk.com"/>
//     *           </remote>
//     *           <local>
//                     <identity display="Conrad De Wet">sip:TTbXG7XMO@ws-eu-west-1.innovateasterisk.com</identity>
//                     <target uri="sip:TTbXG7XMO@ws-eu-west-1.innovateasterisk.com"/>
//                 </local>
//             </dialog>
//         </dialog-info>
//         */
  
//         let ObservedUser = xml.find("dialog-info").attr("entity");
//         buddy = ObservedUser.split("@")[0].split(":")[1];
  
//         let version = xml.find("dialog-info").attr("version"); // 1|2|etc
//         let DialogState = xml.find("dialog-info").attr("state"); // full|partial
//         let extId = xml.find("dialog-info").find("dialog").attr("id"); // qoe2vr886cbn1ccj3h.0
  
//         let state = xml.find("dialog-info").find("dialog").find("state").text();
//         if (state == "terminated") this.headerVariableService.selfPresence =  "Ready";
//         if (state == "trying") this.headerVariableService.selfPresence =  "On the phone";
//         if (state == "proceeding") this.headerVariableService.selfPresence =  "On the phone";
//         if (state == "early") this.headerVariableService.selfPresence =  "Ringing";
//         if (state == "confirmed") this.headerVariableService.selfPresence =  "On the phone";
  
//         // The dialog states only report devices states, and cant say online or offline.
//     }
  
//     if(selfSubscribe){
//         if(buddy == ConstantsService.user.extension){
//             //console.log("Self Notify:", this.headerVariableService.selfPresence);
  
//         }
//         else {
//             console.warn("Self Subscribe Notify, but wrong user returned.", buddy, ConstantsService.user.domain);
//         }
//         return;
//     }
  
//     // dotOnline | dotOffline | dotRinging | dotInUse | dotReady | dotOnHold
//     if (this.headerVariableService.selfPresence == "Not online") this.headerVariableService.dotClass = "dotOffline";
//     if (this.headerVariableService.selfPresence == "Unavailable") this.headerVariableService.dotClass = "dotOffline";
//     if (this.headerVariableService.selfPresence == "Ready") this.headerVariableService.dotClass = "dotOnline";
//     if (this.headerVariableService.selfPresence == "On the phone") this.headerVariableService.dotClass = "dotInUse";
//     if (this.headerVariableService.selfPresence == "Proceeding") this.headerVariableService.dotClass = "dotInUse";
//     if (this.headerVariableService.selfPresence == "Ringing") this.headerVariableService.dotClass = "dotRinging";
//     if (this.headerVariableService.selfPresence == "On hold") this.headerVariableService.dotClass = "dotOnHold";
//     }


//   //DialLine
//     dialLine(type:any, extraHeaders:any){
    
//         //console.log("I am in dialLine");

//         if(this.userAgent == null || this.userAgent.isRegistered() == false){
//             this.showDialoge('Not Registered','activity-outline','danger', 'Browser phone is not registered to call'); 
//             return;
//         }

//         let numDial = this.headerVariableService.dialValue;
//         if(this.headerVariableService.enableAlphanumericDial){
//             numDial = numDial.replace(this.headerVariableService.telAlphanumericRegEx, "").substring(0,this.headerVariableService.maxDidLength);
//         }
//         else {
//             numDial = numDial.replace(this.headerVariableService.telNumericRegEx, "").substring(0,this.headerVariableService.maxDidLength);
//         }
//         if(numDial.length == 0) {
//             console.warn("Enter number to dial");
//             return;
//         }
//         // Start Call Invite
//         if(type == "audio"){
//             this.audioCall(numDial, extraHeaders);
//         } 
//         else {
//             this.videoCall(numDial, extraHeaders);
//         }
//     } 
    
//       // Outbound Calling
//     // ================
//     videoCall(dialledNumber:any, extraHeaders:any) {

//         //console.log("I am in videoCall");

//         if(this.userAgent == null) return;
//         if(!this.userAgent.isRegistered()) return;

//         if(this.headerVariableService.hasAudioDevice == false){
//             this.showDialoge('No Microphone','activity-outline','danger', this.lang.alert_no_microphone); 
//             return;
//         }

//         if(this.headerVariableService.hasVideoDevice == false){
//             console.warn("No video devices (webcam) found, switching to audio call.");
//             this.audioCall(dialledNumber,"");
//             return;
//         }

//         let supportedConstraints = navigator.mediaDevices.getSupportedConstraints();
//         let spdOptions = {
//             //extraHeaders:{},
//             earlyMedia: true,
//             sessionDescriptionHandlerOptions: {
//                 constraints: {
//                     audio: { deviceId : {} },
//                     video: { deviceId : {} }
//                 }
//             }
//         }

//         // Configure Audio
//         let currentAudioDevice = this.headerVariableService.currentMicStringValue;
//         if(currentAudioDevice != "default"){
//             let confirmedAudioDevice = false;
//             for (let i = 0; i < this.headerVariableService.micList.length; ++i) {
//                 if(currentAudioDevice == this.headerVariableService.micList[i].deviceId) {
//                     confirmedAudioDevice = true;
//                     break;
//                 }
//             }
//             if(confirmedAudioDevice) {
//                 spdOptions.sessionDescriptionHandlerOptions.constraints.audio.deviceId = { exact: currentAudioDevice }
//             }
//             else {
//                 console.warn("The audio device you used before is no longer available, default settings applied.");
//             }
//         }
//         // Add additional Constraints
//         if(supportedConstraints.autoGainControl) {
//             spdOptions.sessionDescriptionHandlerOptions.constraints.audio["autoGainControl"] = this.headerVariableService.autoGainControl;
//         }
//         if(supportedConstraints.echoCancellation) {
//             spdOptions.sessionDescriptionHandlerOptions.constraints.audio["echoCancellation"] = this.headerVariableService.echoCancellation;
//         }
//         if(supportedConstraints.noiseSuppression) {
//             spdOptions.sessionDescriptionHandlerOptions.constraints.audio["noiseSuppression"] = this.headerVariableService.noiseSeperation;
//         }

//         // Configure Video
//         let currentVideoDevice = this.headerVariableService.currentVideoStringValue;
//         if(currentVideoDevice != "default"){
//             let confirmedVideoDevice = false;
//             for (let i = 0; i < this.headerVariableService.videoList.length; ++i) {
//                 if(currentVideoDevice == this.headerVariableService.videoList[i].deviceId) {
//                     confirmedVideoDevice = true;
//                     break;
//                 }
//             }
//             if(confirmedVideoDevice){
//                 spdOptions.sessionDescriptionHandlerOptions.constraints.video.deviceId = { exact: currentVideoDevice }
//             }
//             else {
//                 console.warn("The video device you used before is no longer available, default settings applied.");
//             }
//         }
//         // Add additional Constraints
//         if(supportedConstraints.frameRate && this.headerVariableService.maxFrameRate != "") {
//             spdOptions.sessionDescriptionHandlerOptions.constraints.video["frameRate"] = this.headerVariableService.maxFrameRate;
//         }
//         if(supportedConstraints.height && this.headerVariableService.videoHeight != "") {
//             spdOptions.sessionDescriptionHandlerOptions.constraints.video["height"] = this.headerVariableService.videoHeight;
//         }
//         if(supportedConstraints.aspectRatio && this.headerVariableService.videoAspectRatio != "") {
//             spdOptions.sessionDescriptionHandlerOptions.constraints.video["aspectRatio"] = this.headerVariableService.videoAspectRatio;
//         }
//         // Extra Headers
//         if(extraHeaders) {
//             spdOptions["extraHeaders"] = extraHeaders;
//         }

//         this.headerVariableService.browserPhoneTitle = this.lang.starting_video_call;


//         let startTime = moment.utc();

//         // Invite
//         //console.log("INVITE (video): " + dialledNumber + "@" + ConstantsService.user.domain); 

//         let targetURI = UserAgent.makeURI("sip:" + dialledNumber.replace(/#/g, "%23") + "@" + ConstantsService.user.domain);
//         let sipSession:any = new Inviter(this.userAgent, targetURI, spdOptions);
//         sipSession.data = {}
//         sipSession.data.calldirection = "outbound";
//         sipSession.data.dst = dialledNumber;
//         sipSession.data.callstart = startTime.format("YYYY-MM-DD HH:mm:ss UTC");
//         sipSession.data.callTimer = window.setInterval(()=>{
//             let now = moment.utc();
//             let duration = moment.duration(now.diff(startTime)); 
//             let timeStr = this.formatShortDuration(duration.asSeconds());
//             // $("#line-" + lineObj.LineNumber + "-timer").html(timeStr);
//             // $("#line-" + lineObj.LineNumber + "-datetime").html(timeStr);
//         }, 1000);
//         sipSession.data.VideoSourceDevice = this.headerVariableService.currentVideoStringValue;
//         sipSession.data.AudioSourceDevice = this.headerVariableService.currentMicStringValue;
//         sipSession.data.AudioOutputDevice = this.headerVariableService.currentSpeakerStringValue;
//         sipSession.data.terminateby = "them";
//         sipSession.data.withvideo = true;
//         sipSession.data.earlyReject = false;
//         sipSession.isOnHold = false;
//         sipSession.delegate = {
//             onBye: (sip:any)=>{
//                 this.onSessionReceivedBye(sipSession, sip);
//             },
//             onMessage: (sip:any)=>{
//                 this.onSessionReceivedMessage(sipSession, sip);
//             },
//             onInvite: (sip:any)=>{
//                 this.onSessionReinvited(sipSession, sip);
//             },
//             onSessionDescriptionHandler: (sdh:any, provisional:any)=>{
//                 this.onSessionDescriptionHandlerCreated(sipSession, sdh, provisional, true);
//             }
//         }
//         let inviterOptions = {
//             requestDelegate: { // OutgoingRequestDelegate
//                 onTrying: (sip:any)=>{
//                     this.onInviteTrying(sipSession, sip);
//                 },
//                 onProgress:(sip:any)=>{
//                     this.onInviteProgress(sipSession, sip);
//                 },
//                 onRedirect:(sip:any)=>{
//                     this.onInviteRedirected(sipSession, sip);
//                 },
//                 onAccept:(sip:any)=>{
//                     this.onInviteAccepted(sipSession, true, sip);
//                 },
//                 onReject:(sip:any)=>{
//                     this.onInviteRejected(sipSession, sip);
//                 }
//             }
//         }
//         sipSession.invite(inviterOptions).catch((e:any)=>{
//             console.warn("Failed to send INVITE:", e);
//         });

//         // $("#line-" + lineObj.LineNumber + "-btn-settings").removeAttr('disabled');
//         // $("#line-" + lineObj.LineNumber + "-btn-audioCall").prop('disabled','disabled');
//         // $("#line-" + lineObj.LineNumber + "-btn-videoCall").prop('disabled','disabled');
//         // $("#line-" + lineObj.LineNumber + "-btn-search").removeAttr('disabled');

//         // $("#line-" + lineObj.LineNumber + "-progress").show();
//         // $("#line-" + lineObj.LineNumber + "-msg").show();

//     }


//     audioCall(dialledNumber:any, extraHeaders:any) {

//         //console.log("I am in audioCall");

//         if(this.userAgent == null) return;
//         if(this.userAgent.isRegistered() == false) return;

//         if(this.headerVariableService.hasAudioDevice == false){
//             this.showDialoge('No Microphone','activity-outline','danger', this.lang.alert_no_microphone); 
//             return;
//         }

//         let supportedConstraints = navigator.mediaDevices.getSupportedConstraints();

//         let spdOptions = {
//             earlyMedia: true,
//             sessionDescriptionHandlerOptions: {
//                 constraints: {
//                     audio: { deviceId : {} },
//                     video: false
//                 }
//             }
//         }
//         // Configure Audio
//         let currentAudioDevice = this.headerVariableService.currentMicStringValue;
//         if(currentAudioDevice != "default"){
//             let confirmedAudioDevice = false;
//             for (let i = 0; i < this.headerVariableService.micList.length; ++i) {
//                 if(currentAudioDevice == this.headerVariableService.micList[i].deviceId) {
//                     confirmedAudioDevice = true;
//                     break;
//                 }
//             }
//             if(confirmedAudioDevice) {
//                 spdOptions.sessionDescriptionHandlerOptions.constraints.audio.deviceId = { exact: currentAudioDevice }
//             }
//             else {
//                 console.warn("The audio device you used before is no longer available, default settings applied.");
//             }
//         }
//         // Add additional Constraints
//         if(supportedConstraints.autoGainControl) {
//             spdOptions.sessionDescriptionHandlerOptions.constraints.audio["autoGainControl"] = this.headerVariableService.autoGainControl;
//         }
//         if(supportedConstraints.echoCancellation) {
//             spdOptions.sessionDescriptionHandlerOptions.constraints.audio["echoCancellation"] = this.headerVariableService.echoCancellation;
//         }
//         if(supportedConstraints.noiseSuppression) {
//             spdOptions.sessionDescriptionHandlerOptions.constraints.audio["noiseSuppression"] = this.headerVariableService.noiseSeperation;
//         }
//         // Extra Headers
//         if(extraHeaders) {
//             spdOptions["extraHeaders"] = extraHeaders;
//         }

//         // $("#line-" + lineObj.LineNumber + "-timer").show();
//         this.headerVariableService.browserPhoneTitle = this.lang.starting_audio_call;

//         let startTime = moment.utc();

//         // Invite
//         //console.log("INVITE (audio): " + dialledNumber + "@" + ConstantsService.user.domain);

//         let targetURI = UserAgent.makeURI("sip:" + dialledNumber.replace(/#/g, "%23") + "@" + ConstantsService.user.domain);
//         let sipSession:any = new Inviter(this.userAgent, targetURI, spdOptions);
//         sipSession.data = {}
//         sipSession.data.calldirection = "outbound";
//         sipSession.data.dst = dialledNumber;
//         sipSession.data.callstart = startTime.format("YYYY-MM-DD HH:mm:ss UTC");
//         sipSession.data.callTimer = window.setInterval(()=>{
//             let now = moment.utc();
//             let duration = moment.duration(now.diff(startTime)); 
//             let timeStr = this.formatShortDuration(duration.asSeconds());
//             // $("#line-" + lineObj.LineNumber + "-timer").html(timeStr);
//             // $("#line-" + lineObj.LineNumber + "-datetime").html(timeStr);
//         }, 1000);
//         sipSession.data.VideoSourceDevice = null;
//         sipSession.data.AudioSourceDevice = this.headerVariableService.currentMicStringValue;
//         sipSession.data.AudioOutputDevice = this.headerVariableService.currentSpeakerStringValue;
//         sipSession.data.terminateby = "them";
//         sipSession.data.withvideo = false;
//         sipSession.data.earlyReject = false;
//         sipSession.isOnHold = false;
//         sipSession.delegate = {
//             onBye: (sip:any)=>{
//                 this.onSessionReceivedBye(sipSession, sip);
//             },
//             onMessage: (sip:any)=>{
//                 this.onSessionReceivedMessage(sipSession, sip);
//             },
//             onInvite: (sip:any)=>{
//                 this.onSessionReinvited(sipSession, sip);
//             },
//             onSessionDescriptionHandler: (sdh:any, provisional:any)=>{
//                 this.onSessionDescriptionHandlerCreated(sipSession, sdh, provisional, false);
//             }
//         }
//         let inviterOptions = {
//             requestDelegate: { // OutgoingRequestDelegate
//                 onTrying: (sip:any)=>{
//                     this.onInviteTrying(sipSession, sip);
//                 },
//                 onProgress:(sip:any)=>{
//                     this.onInviteProgress(sipSession, sip);
//                 },
//                 onRedirect:(sip:any)=>{
//                     this.onInviteRedirected(sipSession, sip);
//                 },
//                 onAccept:(sip:any)=>{
//                     this.onInviteAccepted(sipSession, false, sip);
//                 },
//                 onReject:(sip:any)=>{
//                     this.onInviteRejected(sipSession, sip);
//                 }
//             }
//         }
//         sipSession.invite(inviterOptions).catch((e:any)=>{
//             console.warn("Failed to send INVITE:", e);
//         });

//         // $("#line-" + lineObj.LineNumber + "-btn-settings").removeAttr('disabled');
//         // $("#line-" + lineObj.LineNumber + "-btn-audioCall").prop('disabled','disabled');
//         // $("#line-" + lineObj.LineNumber + "-btn-videoCall").prop('disabled','disabled');
//         // $("#line-" + lineObj.LineNumber + "-btn-search").removeAttr('disabled');

//         // $("#line-" + lineObj.LineNumber + "-progress").show();
//         // $("#line-" + lineObj.LineNumber + "-msg").show();    
//     }

//       // Outgoing INVITE
//     onInviteTrying(sessionData:any, response:any){
//       //console.log("I am in onInviteTrying");
//       this.headerVariableService.browserPhoneTitle = this.lang.trying;
//     }
    
//     onInviteProgress(sessionData:any, response:any){

//       //console.log("I am in onInviteProgress");
//       //console.log("Call Progress:", response.message.statusCode);
      
//       // Provisional 1xx
//       // response.message.reasonPhrase
//       if(response.message.statusCode == 180){
//         this.headerVariableService.browserPhoneTitle = this.lang.ringing;
//           let soundFile = this.phoneMusicService.audioBlobs.EarlyMedia_European;
//           if(this.userLocale().indexOf("us") > -1) soundFile = this.phoneMusicService.audioBlobs.EarlyMedia_US;
//           if(this.userLocale().indexOf("gb") > -1) soundFile = this.phoneMusicService.audioBlobs.EarlyMedia_UK;
//           if(this.userLocale().indexOf("au") > -1) soundFile = this.phoneMusicService.audioBlobs.EarlyMedia_Australia;
//           if(this.userLocale().indexOf("jp") > -1) soundFile = this.phoneMusicService.audioBlobs.EarlyMedia_Japan;
    
//           // Play Early Media
//           //console.log("Audio:", soundFile.url);
//           if(sessionData.data.earlyMedia){
//               // There is already early media playing
//               // onProgress can be called multiple times
//               // Don't add it again
//               //console.log("Early Media already playing");
//           }
//           else {
//               let earlyMedia:any = new Audio(soundFile.blob);
//               earlyMedia.preload = "auto";
//               earlyMedia.loop = true;
//               earlyMedia.oncanplaythrough = (e:any)=> {
//                   if (typeof earlyMedia.sinkId !== 'undefined' && this.headerVariableService.currentSpeakerStringValue != "default") {
//                       earlyMedia.setSinkId(this.headerVariableService.currentSpeakerStringValue).then(()=> {
//                           //console.log("Set sinkId to:", this.headerVariableService.currentSpeakerStringValue);
//                       }).catch((e:any)=>{
//                           console.warn("Failed not apply setSinkId.", e);
//                       });
//                   }
//                   earlyMedia.play().then(()=>{
//                       // Audio Is Playing
//                   }).catch((e:any)=>{
//                       console.warn("Unable to play audio file.", e);
//                   }); 
//               }
//               sessionData.data.earlyMedia = earlyMedia;
//           }
//       }
//       else if(response.message.statusCode === 183){
//        this.showDialoge('Error','activity-outline','danger', response.message.reasonPhrase + "..."); 
                                                
//           // Add UI to allow DTMF
//         //   $("#line-" + lineObj.LineNumber + "-early-dtmf").show();
//       }
//       else {
//           // 181 = Call is Being Forwarded
//           // 182 = Call is queued (Busy server!)
//           // 199 = Call is Terminated (Early Dialog)
//         this.showDialoge('Error','activity-outline','danger', response.message.reasonPhrase + "..."); 
        
//       }
//     }


//     onInviteRejected(sessionData:any, response:any){
//       //console.log("I am in onInviteRejected");
//       //console.log("INVITE Rejected:", response.message.reasonPhrase);
    
//       sessionData.data.terminateby = "them";
//       sessionData.data.reasonCode = response.message.statusCode;
//       sessionData.data.reasonText = response.message.reasonPhrase;
    
//       this.teardownSession(sessionData);
//     }
    
//     onInviteRedirected(sessionData:any,response:any){
//       //console.log("I am in onInviteRedirected");
//       //console.log("onInviteRedirected", response);
//       // Follow???
//     }

     
//   //RedrawVideoStage
//    redrawStage(sessionData:any, videoChanged:any){
//         //console.log("I am in redrawStage");
//         let videoContainer = this.headerVariableService.videoContainer;
//         let session = sessionData;
//         if(session == null) return;

//         let isVideoPinned = false;
//         let pinnedVideoID = "";

//         // Count and Tag Videos
//         let videoCount = 0;
//         videoContainer.find('video').each((video:any,i:any)=> {
//             let thisRemoteVideoStream = video.srcObject;
//             let videoTrack = thisRemoteVideoStream.getVideoTracks()[0];
//             let videoTrackSettings = videoTrack.getSettings();
//             let srcVideoWidth = (videoTrackSettings.width)? videoTrackSettings.width : video.videoWidth;
//             let srcVideoHeight = (videoTrackSettings.height)? videoTrackSettings.height : video.videoHeight;

//             if(thisRemoteVideoStream.mid) {
//                 thisRemoteVideoStream.channel = "unknown"; // Asterisk Channel
//                 thisRemoteVideoStream.CallerIdName = "";
//                 thisRemoteVideoStream.CallerIdNumber = "";
//                 thisRemoteVideoStream.isAdminMuted = false;
//                 thisRemoteVideoStream.isAdministrator = false;
//                 if(session && session.data && session.data.videoChannelNames){
//                     session.data.videoChannelNames.forEach((videoChannelName:any)=>{
//                         if(thisRemoteVideoStream.mid == videoChannelName.mid){
//                             thisRemoteVideoStream.channel = videoChannelName.channel;
//                         }
//                     });
//                 }
//                 if(session && session.data && session.data.ConfbridgeChannels){
//                     session.data.ConfbridgeChannels.forEach((ConfbridgeChannel:any)=>{
//                         if(ConfbridgeChannel.id == thisRemoteVideoStream.channel){
//                             thisRemoteVideoStream.CallerIdName = ConfbridgeChannel.caller.name;
//                             thisRemoteVideoStream.CallerIdNumber = ConfbridgeChannel.caller.number;
//                             thisRemoteVideoStream.isAdminMuted = ConfbridgeChannel.muted;
//                             thisRemoteVideoStream.isAdministrator = ConfbridgeChannel.admin;
//                         }
//                     });
//                 }
//                 // //console.log("Track MID :", thisRemoteVideoStream.mid, thisRemoteVideoStream.channel);
//             }

//             // Remove any in the preview area
//             // if(videoChanged){
//             //     $("#line-" + lineNum + "-preview-container").find('video').each((video:any, i:any)=> {
//             //         if(video.id.indexOf("copy-") == 0){
//             //             video.remove();
//             //         }
//             //     });
//             // }

//             // Count Videos
//             if(videoTrack.readyState == "live" && srcVideoWidth > 10 && srcVideoHeight >= 10){
//                 // A valid and live video is pinned
//                 isVideoPinned = true;
//                 pinnedVideoID = thisRemoteVideoStream.trackID;
//             }
//             // Count All the videos
//             if(videoTrack.readyState == "live" && srcVideoWidth > 10 && srcVideoHeight >= 10) {
//                 videoCount ++;
//                 //console.log("Display Video - ", videoTrack.readyState, "MID:", thisRemoteVideoStream.mid, "channel:", thisRemoteVideoStream.channel, "src width:", srcVideoWidth, "src height", srcVideoHeight);
//             }
//             else{
//                 //console.log("Hide Video - ", videoTrack.readyState ,"MID:", thisRemoteVideoStream.mid);
//             }


//         });
        
//         if(isVideoPinned) videoCount = 1;


//         // videoAspectRatio (1|1.33|1.77) is for the peer video, so can technically be used here
//         // default ia 4:3
//         let Margin = 3;
//         let videoRatio = 0.750; // 0.5625 = 9/16 (16:9) | 0.75   = 3/4 (4:3)
//         if(this.headerVariableService.videoAspectRatio == "" || this.headerVariableService.videoAspectRatio == "1.33") videoRatio = 0.750;  
//         if(this.headerVariableService.videoAspectRatio == "1.77") videoRatio = 0.5625;
//         if(this.headerVariableService.videoAspectRatio == "1") videoRatio = 1;
//         let stageWidth = videoContainer.outerWidth() - (Margin * 2);
//         let stageHeight = videoContainer.outerHeight() - (Margin * 2);
//         let maxWidth = 0;
//         let i = 1;
//         while (i < 5000) {
//             let w:any = 'StageArea(i, videoCount, stageWidth, stageHeight, Margin, videoRatio);'
//             if (w === false) {
//                 maxWidth =  i - 1;
//                 break;
//             }
//             i++;
//         }
//         maxWidth = maxWidth - (Margin * 2);

//         // Layout Videos
//         videoContainer.find('video').each((video:any,i:any)=> {
//             let thisRemoteVideoStream = video.srcObject;
//             let videoTrack = thisRemoteVideoStream.getVideoTracks()[0];
//             let videoTrackSettings = videoTrack.getSettings();
//             let srcVideoWidth = (videoTrackSettings.width)? videoTrackSettings.width : video.videoWidth;
//             let srcVideoHeight = (videoTrackSettings.height)? videoTrackSettings.height : video.videoHeight;

//             let videoWidth = maxWidth;
//             let videoHeight = maxWidth * videoRatio;

//             // Set & Show
//             if(isVideoPinned){
//                 // One of the videos are pinned
//                 if(pinnedVideoID == video.srcObject.trackID){
                    
//                 } else {
//                     // Put the videos in the preview area
//                     if(videoTrack.readyState == "live" && srcVideoWidth > 10 && srcVideoHeight >= 10) {
//                         if(videoChanged){
//                             // let videoEl = $("<video />", {
//                             //     id: "copy-"+ thisRemoteVideoStream.id,
//                             //     muted: true,
//                             //     autoplay: true,
//                             //     playsinline: true,
//                             //     controls: false
//                             // });
//                             // let videoObj = videoEl.get(0);
//                             // videoObj.srcObject = thisRemoteVideoStream;
//                             // $("#line-" + lineNum + "-preview-container").append(videoEl);
//                         }
//                     }
//                 }
//             }
//             else {
//                 // None of the videos are pinned
//                 if(videoTrack.readyState == "live" && srcVideoWidth > 10 && srcVideoHeight >= 10) {
//                     // Unpinned 
//                     // Unpinned Actions
//                 }
//             }

//             // Populate Caller ID
//             let adminMuteIndicator = "";
//             let administratorIndicator = "";
//             if(thisRemoteVideoStream.isAdminMuted == true){
//                 adminMuteIndicator = "<i class=\"fa fa-microphone-slash\" style=\"color:red\"></i>&nbsp;"
//             }
//             if(thisRemoteVideoStream.isAdministrator == true){
//                 administratorIndicator = "<i class=\"fa fa-user\" style=\"color:orange\"></i>&nbsp;"
//             }
//             if(thisRemoteVideoStream.CallerIdName == ""){
//                 thisRemoteVideoStream.CallerIdName = 'FindBuddyByIdentity(session.data.buddyId).CallerIDName';
//             }
//          });
//     }

//     //OnGoing Call Func

//     // Call Transfer
//     // =============
//     startTransferSession(sessionData:any){
//         //console.log("I am in startTransferSession");
//         if(this.headerVariableService.isConference){
//             this.cancelConference(sessionData);
//             return;
//         }
//         this.holdSession(sessionData);
//     }
    
    
//     cancelTransferSession(sessionData:any){
//         //console.log("I am in cancelTransferSession");
//         let session = sessionData;
//         if(session.data.childsession){
//             //console.log("Child Transfer call detected:", session.data.childsession.state);
//             session.data.childsession.dispose().then(()=>{
//                 session.data.childsession = null;
//             }).catch((error:any)=>{
//                 session.data.childsession = null;
//                 // Suppress message
//             });
//         }    
//         this.unholdSession(session);
//     }

//     cancelAttendedTransferSession(sessionData:any,transferId:any){
//         //console.log("I am in cancelAttendedTransferSession");
//         let session = sessionData;
//         if(session.data.childsession){
//             //console.log("Child Transfer call detected:", session.data.childsession.state);
//             session.data.childsession.cancel().catch((error:any)=>{
//                 console.warn("Failed to CANCEL", error);
//             });
//             //newCallStatus.html(this.lang.call_cancelled);
//             //console.log("New call session canceled");

//             session.data.transfer[transferId].accept.complete = false;
//             session.data.transfer[transferId].accept.disposition = "cancel";
//             //session.data.transfer[transferId].accept.eventTime = this.utcDateNow();

//            this.headerVariableService.browserPhoneTitle = this.lang.attended_transfer_call_cancelled;
//         }    
           
//         this.unholdSession(session);
//     }

//     terminateAttendedTransferSession(sessionData:any,transferId:any){
//         //console.log("I am in terminateAttendedTransferSession");
//         let session = sessionData;
//         if(session.data.childsession){
//             //console.log("Child Transfer call detected:", session.data.childsession.state);
//             session.data.childsession.bye().catch((error:any)=>{
//                 console.warn("Failed to BYE", error);
//             });
//         }

//         this.headerVariableService.browserPhoneTitle = this.lang.call_ended;
//         //console.log("New call session end");

//         session.data.transfer[transferId].accept.complete = false;
//         session.data.transfer[transferId].accept.disposition = "bye";
//         session.data.transfer[transferId].accept.eventTime = this.utcDateNow();

//         this.headerVariableService.browserPhoneTitle = this.lang.attended_transfer_call_ended;

//         window.setTimeout(()=>{
//             this.cancelTransferSession(session);
//         }, 1000);
//     }

//     blindTransfer(sessionData:any) {
//         //console.log("I am in blindTransfer");
//         this.startTransferSession(sessionData);

//         let dstNo:any = ConstantsService.user.transfer_phone_2;
//         if(this.headerVariableService.enableAlphanumericDial){
//             dstNo = String(dstNo).replace(this.headerVariableService.telAlphanumericRegEx, "").substring(0,this.headerVariableService.maxDidLength);
//         }
//         else {
//             dstNo = String(dstNo).replace(this.headerVariableService.telNumericRegEx, "").substring(0,this.headerVariableService.maxDidLength);
//         }
//         if(dstNo == ""){
//             console.warn("Cannot transfer, no number");
//             return;
//         }
    
//         let session = sessionData;
    
//         if(!session.data.transfer) session.data.transfer = [];
//         session.data.transfer.push({ 
//             type: "Blind", 
//             to: dstNo, 
//             transferTime: this.utcDateNow(), 
//             disposition: "refer",
//             dispositionTime: this.utcDateNow(), 
//             accept : {
//                 complete: null,
//                 eventTime: null,
//                 disposition: ""
//             }
//         });
//         let transferId = session.data.transfer.length-1;
    
//         let transferOptions  = { 
//             requestDelegate: {
//                 onAccept: (sip:any)=>{
//                     //console.log("Blind transfer Accepted");
    
//                     session.data.terminateby = "us";
//                     session.data.reasonCode = 202;
//                     session.data.reasonText = "Transfer";
                
//                     session.data.transfer[transferId].accept.complete = true;
//                     session.data.transfer[transferId].accept.disposition = sip.message.reasonPhrase;
//                     session.data.transfer[transferId].accept.eventTime = this.utcDateNow();
    
//                     // TODO: use lang pack
//                   this.showDialoge('Information','activity-outline','success', "Call Blind Transferred (Accepted)"); 
                                               
//                     session.bye().catch((error:any)=>{
//                         console.warn("Could not BYE after blind transfer:", error);
//                     });
//                     this.teardownSession(session);
//                 },
//                 onReject:(sip:any)=>{
//                     console.warn("REFER rejected:", sip);
    
//                     session.data.transfer[transferId].accept.complete = false;
//                     session.data.transfer[transferId].accept.disposition = sip.message.reasonPhrase;
//                     session.data.transfer[transferId].accept.eventTime = this.utcDateNow();
//                     this.showDialoge('Information','activity-outline','danger', "Call Blind Transferred (Rejected)"); 
                  
//                     // Session should still be up, so just allow them to try again
//                 }
//             }
//         }
//         //console.log("REFER: ", dstNo + "@" + ConstantsService.user.domain);
//         let referTo = UserAgent.makeURI("sip:"+ dstNo.replace(/#/g, "%23") + "@" + ConstantsService.user.domain);
//         session.refer(referTo, transferOptions).catch((error:any)=>{
//             console.warn("Failed to REFER", error);
//         });;

//     }

//     attendedTransfer(sessionData:any){
//         //console.log("I am in attendedTransfer");
//         this.startTransferSession(sessionData);

//         let dstNo:any = ConstantsService.user.transfer_phone_1;

//         if(this.headerVariableService.enableAlphanumericDial){
//             dstNo = String(dstNo).replace(this.headerVariableService.telAlphanumericRegEx, "").substring(0,this.headerVariableService.maxDidLength);
//         }
//         else {
//             dstNo = String(dstNo).replace(this.headerVariableService.telNumericRegEx, "").substring(0,this.headerVariableService.maxDidLength);
//         }
//         if(dstNo == ""){
//             console.warn("Cannot transfer, no number");
//             return;
//         }
        

//         let session = sessionData;
//         this.headerVariableService.browserPhoneTitle = this.lang.connecting;

//         if(!session.data.transfer) session.data.transfer = [];
//         session.data.transfer.push({ 
//             type: "Attended", 
//             to: dstNo, 
//             transferTime: this.utcDateNow(), 
//             disposition: "invite",
//             dispositionTime: this.utcDateNow(), 
//             accept : {
//                 complete: null,
//                 eventTime: null,
//                 disposition: ""
//             }
//         });
//         let transferId = session.data.transfer.length-1;
//         this.headerVariableService.AttendedTransferId = transferId;

//         // SDP options
//         let supportedConstraints = navigator.mediaDevices.getSupportedConstraints();
//         let spdOptions = {
//             earlyMedia: true,
//             sessionDescriptionHandlerOptions: {
//                 constraints: {
//                     audio: { deviceId : {} },
//                     video: false
//                 }
//             }
//         }
//         if(session.data.AudioSourceDevice != "default"){
//             spdOptions.sessionDescriptionHandlerOptions.constraints.audio.deviceId = { exact: session.data.AudioSourceDevice }
//         }
//         // Add additional Constraints
//         if(supportedConstraints.autoGainControl) {
//             spdOptions.sessionDescriptionHandlerOptions.constraints.audio["autoGainControl"] = this.headerVariableService.autoGainControl;
//         }
//         if(supportedConstraints.echoCancellation) {
//             spdOptions.sessionDescriptionHandlerOptions.constraints.audio["echoCancellation"] = this.headerVariableService.echoCancellation;
//         }
//         if(supportedConstraints.noiseSuppression) {
//             spdOptions.sessionDescriptionHandlerOptions.constraints.audio["noiseSuppression"] = this.headerVariableService.noiseSeperation;
//         }
    
//         // Not sure if its possible to transfer a Video call???
//         if(session.data.withvideo){
//             spdOptions.sessionDescriptionHandlerOptions.constraints.video = true;
//             if(session.data.VideoSourceDevice != "default"){
//                 spdOptions.sessionDescriptionHandlerOptions.constraints.video["deviceId"] = { exact: session.data.VideoSourceDevice }
//             }
//             // Add additional Constraints
//             if(supportedConstraints.frameRate && this.headerVariableService.maxFrameRate != "") {
//                 spdOptions.sessionDescriptionHandlerOptions.constraints.video["frameRate"] = this.headerVariableService.maxFrameRate;
//             }
//             if(supportedConstraints.height && this.headerVariableService.videoHeight != "") {
//                 spdOptions.sessionDescriptionHandlerOptions.constraints.video["height"] = this.headerVariableService.videoHeight;
//             }
//             if(supportedConstraints.aspectRatio && this.headerVariableService.videoAspectRatio != "") {
//                 spdOptions.sessionDescriptionHandlerOptions.constraints.video["aspectRatio"] = this.headerVariableService.videoAspectRatio;
//             }
//         }
    
//         // Create new call session
//         //console.log("TRANSFER INVITE: ", "sip:" + dstNo + "@" + ConstantsService.user.domain);
//         let targetURI = UserAgent.makeURI("sip:"+ dstNo.replace(/#/g, "%23") + "@" + ConstantsService.user.domain);
//         let newSession = new Inviter(this.userAgent, targetURI, spdOptions);
//         newSession.data = {}
//         newSession.delegate = {
//             onBye: (sip:any)=>{
//                 //console.log("New call session ended with BYE");
//                 this.headerVariableService.browserPhoneTitle = this.lang.call_ended;
//                 session.data.transfer[transferId].disposition = "bye";
//                 session.data.transfer[transferId].dispositionTime = this.utcDateNow();
//                 //Calls gets disconnected

//             },
//             onSessionDescriptionHandler: (sdh:any, provisional:any)=>{
//                 if (sdh) {
//                     if(sdh.peerConnection){
//                         sdh.peerConnection.ontrack = (event:any)=>{
//                             let pc = sdh.peerConnection;
    
//                             // Gets Remote Audio Track (Local audio is setup via initial GUM)
//                             let remoteStream = new MediaStream();
//                             pc.getReceivers().forEach((receiver:any) => {
//                                 if(receiver.track && receiver.track.kind == "audio"){
//                                     remoteStream.addTrack(receiver.track);
//                                 }
//                             });
//                            let remoteAudio:any = this.headerVariableService.remoteAudio;
//                             remoteAudio.srcObject = remoteStream;
//                             remoteAudio.onloadedmetadata = (e:any)=> {
//                                 if (typeof remoteAudio.sinkId !== 'undefined') {
//                                     remoteAudio.setSinkId(session.data.AudioOutputDevice).then(()=>{
//                                         //console.log("sinkId applied: "+ session.data.AudioOutputDevice);
//                                     }).catch((e:any)=>{
//                                         console.warn("Error using setSinkId: ", e);
//                                     });
//                                 }
//                                 remoteAudio.play();
//                             }
    
//                         }
//                     }
//                     else{
//                         console.warn("onSessionDescriptionHandler fired without a peerConnection");
//                     }
//                 }
//                 else{
//                     console.warn("onSessionDescriptionHandler fired without a sessionDescriptionHandler");
//                 }
//             }
//         }
//         session.data.childsession = newSession;
//         let inviterOptions = {
//             requestDelegate: {
//                 onTrying: (sip:any)=>{
//                     this.headerVariableService.browserPhoneTitle = this.lang.trying;
//                     session.data.transfer[transferId].disposition = "trying";
//                     session.data.transfer[transferId].dispositionTime = this.utcDateNow();
//                     this.headerVariableService.browserPhoneTitle = this.lang.attended_transfer_call_started;
//                 },
//                 onProgress:(sip:any)=>{
//                     this.headerVariableService.browserPhoneTitle = this.lang.ringing;
//                     session.data.transfer[transferId].disposition = "progress";
//                     session.data.transfer[transferId].dispositionTime = this.utcDateNow();
//                     this.cancelAttendedTransferSession(session,transferId);
//                     this.headerVariableService.browserPhoneTitle = this.lang.attended_transfer_call_started;
//                 },
//                 onRedirect:(sip:any)=>{
//                     //console.log("Redirect received:", sip);
//                 },
//                 onAccept:(sip:any)=>{
//                     this.headerVariableService.browserPhoneTitle = this.lang.call_in_progress;

//                     session.data.transfer[transferId].disposition = "accepted";
//                     session.data.transfer[transferId].dispositionTime = this.utcDateNow();
                    
//                     let transferOptions  = { 
//                         requestDelegate: {
//                             onAccept: (sip:any)=>{
//                                 //console.log("Attended transfer Accepted");

//                                 session.data.terminateby = "us";
//                                 session.data.reasonCode = 202;
//                                 session.data.reasonText = "Attended Transfer";

//                                 session.data.transfer[transferId].accept.complete = true;
//                                 session.data.transfer[transferId].accept.disposition = sip.message.reasonPhrase;
//                                 session.data.transfer[transferId].accept.eventTime = this.utcDateNow();

//                               this.showDialoge('Information','activity-outline','success', "Call Attended Transferred (Accepted)"); 
//                                 // We must end this session manually
//                                 session.bye().catch((error:any)=>{
//                                     console.warn("Could not BYE after blind transfer:", error);
//                                 });

//                                 this.teardownSession(session);
//                             },
//                             onReject: (sip:any)=>{
//                                 console.warn("Attended transfer rejected:", sip);

//                                 session.data.transfer[transferId].accept.complete = false;
//                                 session.data.transfer[transferId].accept.disposition = sip.message.reasonPhrase;
//                                 session.data.transfer[transferId].accept.eventTime = this.utcDateNow();

//                                 this.showDialoge('Information','activity-outline','danger', "Call Attended Transferred (Rejected)"); 
              
//                             }
//                         }
//                     }
        
//                     // Send REFER
//                     session.refer(newSession, transferOptions).catch((error:any)=>{
//                         console.warn("Failed to REFER", error);
//                     });
        
//                    this.headerVariableService.browserPhoneTitle = this.lang.attended_transfer_complete;
//                 //    this.terminateAttendedTransferSession(session,transferId);
//                 //    this.headerVariableService.browserPhoneTitle = this.lang.attended_transfer_call_ended;


//                 },
//                 onReject:(sip:any)=>{
//                     //console.log("New call session rejected: ", sip.message.reasonPhrase);
//                     this.headerVariableService.browserPhoneTitle = this.lang.call_rejected;
//                     session.data.transfer[transferId].disposition = sip.message.reasonPhrase;
//                     session.data.transfer[transferId].dispositionTime = this.utcDateNow();
//                     this.headerVariableService.browserPhoneTitle = this.lang.attended_transfer_call_rejected;
//                 }
//             }
//         }
//         newSession.invite(inviterOptions).catch((e:any)=>{
//             console.warn("Failed to send INVITE:", e);
//         });
//     }
    
//     // Conference Calls
//     // ================
//     startConferenceCall(sessionData:any){
//         //console.log("I am in startConferenceCall");
//         if(this.headerVariableService.isTransfer){
//           this.cancelTransferSession(sessionData);
//             return;
//         }
//         this.holdSession(sessionData);
//     }
    
//     cancelConference(sessionData:any){
//         //console.log("I am in cancelConference");
//         let session = sessionData;
//         if(session.data.childsession){
//             //console.log("Child Conference call detected:", session.data.childsession.state);
//             session.data.childsession.dispose().then(()=>{
//                 session.data.childsession = null;
//             }).catch((error:any)=>{
//                 session.data.childsession = null;
//                 // Suppress message
//             });
//         }
//         this.unholdSession(session);
//     }

//     joinConferenceCall(sessionData:any,confCallId:any)
//     {
//         //console.log("I am in joinConferenceCall");

//           // Merge Call Audio
//           if(!sessionData.data.childsession){
//             console.warn("Conference session lost");
//             return;
//         }

//         let outputStreamForSession = new MediaStream();
//         let outputStreamForConfSession = new MediaStream();

//         let pc = sessionData.sessionDescriptionHandler.peerConnection;
//         let confPc = sessionData.data.childsession.sessionDescriptionHandler.peerConnection;

//         // Get conf call input channel
//         confPc.getReceivers().forEach((RTCRtpReceiver:any) =>{
//             if(RTCRtpReceiver.track && RTCRtpReceiver.track.kind == "audio") {
//                 //console.log("Adding conference session:", RTCRtpReceiver.track.label);
//                 outputStreamForSession.addTrack(RTCRtpReceiver.track);
//             }
//         });

//         // Get session input channel
//         pc.getReceivers().forEach((RTCRtpReceiver:any)=> {
//             if(RTCRtpReceiver.track && RTCRtpReceiver.track.kind == "audio") {
//                 //console.log("Adding conference session:", RTCRtpReceiver.track.label);
//                 outputStreamForConfSession.addTrack(RTCRtpReceiver.track);
//             }
//         });

//         // Replace tracks of Parent Call
//         pc.getSenders().forEach((RTCRtpSender:any) =>{
//             if(RTCRtpSender.track && RTCRtpSender.track.kind == "audio") {
//                 //console.log("Switching to mixed Audio track on session");

//                 sessionData.data.AudioSourceTrack = RTCRtpSender.track;
//                 outputStreamForSession.addTrack(RTCRtpSender.track);
//                 //let mixedAudioTrack = this.mixAudioStreams(outputStreamForSession).getAudioTracks()[0];
//                 //mixedAudioTrack.IsMixedTrack = true;

//                 //RTCRtpSender.replaceTrack(mixedAudioTrack);
//             }
//         });
//         // Replace tracks of Child Call
//         confPc.getSenders().forEach((RTCRtpSender:any)=> {
//             if(RTCRtpSender.track && RTCRtpSender.track.kind == "audio") {
//                 //console.log("Switching to mixed Audio track on conf call");

//                 sessionData.data.childsession.data.AudioSourceTrack = RTCRtpSender.track;
//                 outputStreamForConfSession.addTrack(RTCRtpSender.track);
//                 let mixedAudioTrackForConf = this.mixAudioStreams(outputStreamForConfSession).getAudioTracks()[0];
//                 mixedAudioTrackForConf.IsMixedTrack = true;

//                 RTCRtpSender.replaceTrack(mixedAudioTrackForConf);
//             }
//         });

//        // newCallStatus.html(this.lang.call_in_progress);
//         //console.log("Conference Call In Progress");

//         sessionData.data.confcalls[confCallId].accept.complete = true;
//         sessionData.data.confcalls[confCallId].accept.disposition = "join";
//         //session.data.confcalls[confCallId].accept.eventTime = this.utcDateNow();

//       //   $("#line-"+ lineNum +"-btn-terminate-conference-call").show();

//        // $("#line-" + lineNum + "-msg").html(this.lang.conference_call_in_progress);

//         // Take the parent call off hold after a second
//         window.setTimeout(()=>{
//           this.unholdSession(sessionData);
//         }, 1000);
//     }

//     terminateConferenceSession(sessionData:any,confCallId:any){
//         //console.log("I am in terminateConferenceSession");
//         let session = sessionData;
//         if(session.data.childsession){
//             //console.log("Child Transfer call detected:", session.data.childsession.state);
//             session.data.childsession.bye().catch((e:any)=>{
//                 console.warn("Failed to BYE", e);
//             });
//             this.headerVariableService.browserPhoneTitle = this.lang.call_ended;
//             //console.log("New call session end");

//             session.data.confcalls[confCallId].accept.complete = false;
//             session.data.confcalls[confCallId].accept.disposition = "bye";
//             session.data.confcalls[confCallId].accept.eventTime = this.utcDateNow();
//            this.headerVariableService.browserPhoneTitle = this.lang.conference_call_ended;

//             window.setTimeout(()=>{
//                 this.cancelConference(session);
//             }, 1000);
//         }
//     }   

//     ConferenceDial(sessionData:any){
//         //console.log("I am in ConferenceDial");
//         let dstNo:any = ConstantsService.user.confExtension;
//         if(this.headerVariableService.enableAlphanumericDial){
//             dstNo = String(dstNo).replace(this.headerVariableService.telAlphanumericRegEx, "").substring(0,this.headerVariableService.maxDidLength);
//         }
//         else {
//             dstNo = String(dstNo).replace(this.headerVariableService.telNumericRegEx, "").substring(0,this.headerVariableService.maxDidLength);
//         }
//         if(dstNo == ""){
//             console.warn("Cannot transfer, must be [0-9*+#]");
//             return;
//         }
        
//         let session = sessionData;

//         this.headerVariableService.browserPhoneTitle = this.lang.connecting;
    
//         if(!session.data.confcalls) session.data.confcalls = [];
//         session.data.confcalls.push({ 
//             to: dstNo, 
//             startTime: this.utcDateNow(), 
//             disposition: "invite",
//             dispositionTime: this.utcDateNow(), 
//             accept : {
//                 complete: null,
//                 eventTime: null,
//                 disposition: ""
//             }
//         });
//         let confCallId = session.data.confcalls.length-1;
//         this.headerVariableService.confCallId = confCallId;
    
//         // SDP options
//         let supportedConstraints = navigator.mediaDevices.getSupportedConstraints();
//         let spdOptions = {
//             sessionDescriptionHandlerOptions: {
//                 earlyMedia: true,
//                 constraints: {
//                     audio: { deviceId : {} },
//                     video: false
//                 }
//             }
//         }
//         if(session.data.AudioSourceDevice != "default"){
//             spdOptions.sessionDescriptionHandlerOptions.constraints.audio.deviceId = { exact: session.data.AudioSourceDevice }
//         }
//         // Add additional Constraints
//         if(supportedConstraints.autoGainControl) {
//             spdOptions.sessionDescriptionHandlerOptions.constraints.audio["autoGainControl"] = this.headerVariableService.autoGainControl;
//         }
//         if(supportedConstraints.echoCancellation) {
//             spdOptions.sessionDescriptionHandlerOptions.constraints.audio["echoCancellation"] = this.headerVariableService.echoCancellation;
//         }
//         if(supportedConstraints.noiseSuppression) {
//             spdOptions.sessionDescriptionHandlerOptions.constraints.audio["noiseSuppression"] = this.headerVariableService.noiseSeperation;
//         }
    
//         // Unlikely this will work
//         if(session.data.withvideo){
//             spdOptions.sessionDescriptionHandlerOptions.constraints.video = true;
//             if(session.data.VideoSourceDevice != "default"){
//                 spdOptions.sessionDescriptionHandlerOptions.constraints.video["deviceId"] = { exact: session.data.VideoSourceDevice }
//             }
//             // Add additional Constraints
//             if(supportedConstraints.frameRate && this.headerVariableService.maxFrameRate != "") {
//                 spdOptions.sessionDescriptionHandlerOptions.constraints.video["frameRate"] = this.headerVariableService.maxFrameRate;
//             }
//             if(supportedConstraints.height && this.headerVariableService.videoHeight != "") {
//                 spdOptions.sessionDescriptionHandlerOptions.constraints.video["height"] = this.headerVariableService.videoHeight;
//             }
//             if(supportedConstraints.aspectRatio && this.headerVariableService.videoAspectRatio != "") {
//                 spdOptions.sessionDescriptionHandlerOptions.constraints.video["aspectRatio"] =this.headerVariableService.videoAspectRatio;
//             }
//         }
    
//         // Create new call session
//         //console.log("CONFERENCE INVITE: ", "sip:" + dstNo + "@" + ConstantsService.user.domain);
    
//         let targetURI = UserAgent.makeURI("sip:"+ dstNo.replace(/#/g, "%23") + "@" + ConstantsService.user.domain);
//         let newSession = new Inviter(this.userAgent, targetURI, spdOptions);
//         newSession.data = {}
//         newSession.delegate = {
//             onBye: (sip:any)=>{
//                 //console.log("New call session ended with BYE");
//                 this.headerVariableService.browserPhoneTitle = this.lang.call_ended;
//                 session.data.confcalls[confCallId].disposition = "bye";
//                 session.data.confcalls[confCallId].dispositionTime = this.utcDateNow();
//                 this.headerVariableService.browserPhoneTitle = this.lang.conference_call_terminated;
        
//                 //Remove call UI as call has ended
//                 this.headerVariableService.callInProgress = false;
//                 this.headerVariableService.callStatus = "danger";

//             },
//             onSessionDescriptionHandler: (sdh:any, provisional:any)=>{
//                 if (sdh) {
//                     if(sdh.peerConnection){
//                         sdh.peerConnection.ontrack = (event:any)=>{
//                             let pc = sdh.peerConnection;
    
//                             // Gets Remote Audio Track (Local audio is setup via initial GUM)
//                             let remoteStream = new MediaStream();
//                             pc.getReceivers().forEach((receiver:any) =>{
//                                 if(receiver.track && receiver.track.kind == "audio"){
//                                     remoteStream.addTrack(receiver.track);
//                                 }
//                             });
//                            let remoteAudio = this.headerVariableService.remoteAudio;
//                             remoteAudio.srcObject = remoteStream;
//                             remoteAudio.onloadedmetadata = (e:any)=> {
//                                 if (typeof remoteAudio.sinkId !== 'undefined') {
//                                     remoteAudio.setSinkId(session.data.AudioOutputDevice).then(()=>{
//                                         //console.log("sinkId applied: "+ session.data.AudioOutputDevice);
//                                     }).catch((e:any)=>{
//                                         console.warn("Error using setSinkId: ", e);
//                                     });
//                                 }
//                                 remoteAudio.play();
//                             }
//                         }
//                     }
//                     else{
//                         console.warn("onSessionDescriptionHandler fired without a peerConnection");
//                     }
//                 }
//                 else{
//                     console.warn("onSessionDescriptionHandler fired without a sessionDescriptionHandler");
//                 }
//             }
//         }
//         // Make sure we always restore audio paths
//         newSession.stateChange.addListener((newState:any)=>{
//             if (newState == SessionState.Terminated) {
//                 // Ends the mixed audio, and releases the mic
//                 if(session.data.childsession.data.AudioSourceTrack && session.data.childsession.data.AudioSourceTrack.kind == "audio"){
//                     session.data.childsession.data.AudioSourceTrack.stop();
//                 }
//                 // Restore Audio Stream as it was changed
//                 if(session.data.AudioSourceTrack && session.data.AudioSourceTrack.kind == "audio"){
//                     let pc = session.sessionDescriptionHandler.peerConnection;
//                     pc.getSenders().forEach((RTCRtpSender) => {
//                         if(RTCRtpSender.track && RTCRtpSender.track.kind == "audio") {
//                             RTCRtpSender.replaceTrack(session.data.AudioSourceTrack).then(()=>{
//                                 if(session.data.ismute){
//                                     RTCRtpSender.track.enabled = false;
//                                 }
//                                 else {
//                                     RTCRtpSender.track.enabled = true;
//                                 }
//                             }).catch(()=>{
//                                 //console.error(e);
//                             });
//                             session.data.AudioSourceTrack = null;
//                         }
//                     });
//                 }
//             }
//         });
//         session.data.childsession = newSession;
//         let inviterOptions = {
//             requestDelegate: {
//                 onTrying: (sip:any)=>{
//                     this.headerVariableService.browserPhoneTitle = this.lang.ringing;
//                     session.data.confcalls[confCallId].disposition = "trying";
//                     session.data.confcalls[confCallId].dispositionTime = this.utcDateNow();
//                     this.headerVariableService.browserPhoneTitle = this.lang.conference_call_started;
//                 },
//                 onProgress:(sip:any)=>{
//                     this.headerVariableService.browserPhoneTitle = this.lang.ringing;
//                     session.data.confcalls[confCallId].disposition = "progress";
//                     session.data.confcalls[confCallId].dispositionTime = this.utcDateNow();
//                     this.headerVariableService.browserPhoneTitle = this.lang.conference_call_started;
    
//                     newSession.cancel().catch((error:any)=>{
//                         console.warn("Failed to CANCEL", error);
//                     });
//                    // newCallStatus.html(this.lang.call_cancelled);
//                     //console.log("New call session canceled");
        
//                     session.data.confcalls[confCallId].accept.complete = false;
//                     session.data.confcalls[confCallId].accept.disposition = "cancel";
//                     session.data.confcalls[confCallId].accept.eventTime = this.utcDateNow();
//                     this.headerVariableService.browserPhoneTitle = this.lang.conference_call_cancelled;
//                 },
//                 onRedirect:(sip:any)=>{
//                     //console.log("Redirect received:", sip);
//                 },
//                 onAccept:(sip:any)=>{
//                     this.headerVariableService.browserPhoneTitle = this.lang.call_in_progress;
//                     session.data.confcalls[confCallId].complete = true;
//                     session.data.confcalls[confCallId].disposition = "accepted";
//                     session.data.confcalls[confCallId].dispositionTime = this.utcDateNow();

//                 },
//                 onReject:(sip:any)=>{
//                     //console.log("New call session rejected: ", sip.message.reasonPhrase);
//                     this.headerVariableService.browserPhoneTitle = this.lang.call_rejected;
//                     session.data.confcalls[confCallId].disposition = sip.message.reasonPhrase;
//                     session.data.confcalls[confCallId].dispositionTime = this.utcDateNow();
//                 }
//             }
//         }
//         newSession.invite(inviterOptions).catch((e:any)=>{
//             console.warn("Failed to send INVITE:", e);
//         });
//     }
    
//     // In-Session Call Func
//     // ============================= 
//     cancelSession(sessionData:any) {
//         //console.log("I am in cancelSession");
//         sessionData.data.terminateby = "us";
//         sessionData.data.reasonCode = 0;
//         sessionData.data.reasonText = "Call Cancelled";
    
//         //console.log("Cancelling session : "+ sessionData);
//         if(sessionData.state == SessionState.Initial || sessionData.state == SessionState.Establishing){
//             sessionData.cancel();
//         }
//         else {
//             console.warn("Session not in correct state for cancel.", sessionData.state);
//             //console.log("Attempting teardown : "+ sessionData);
//             this.teardownSession(sessionData);
//         }
//        this.headerVariableService.browserPhoneTitle = this.lang.call_cancelled;
//     }

//     holdSession(sessionData:any) {
//         //console.log("I am in holdSession");
//         let session = sessionData;
//         if(session.isOnHold == true) {
//             //console.log("Call is is already on hold:", session);
//             return;
//         }
//         //console.log("Putting Call on hold:", session);
//         session.isOnHold = true;
    
//         let sessionDescriptionHandlerOptions = session.sessionDescriptionHandlerOptionsReInvite;
//         sessionDescriptionHandlerOptions.hold = true;
//         session.sessionDescriptionHandlerOptionsReInvite = sessionDescriptionHandlerOptions;
    
//         let options = {
//             requestDelegate: {
//                 onAccept: ()=>{
//                     if(session && session.sessionDescriptionHandler && session.sessionDescriptionHandler.peerConnection){
//                         let pc = session.sessionDescriptionHandler.peerConnection;
//                         // Stop all the inbound streams
//                         pc.getReceivers().forEach((RTCRtpReceiver:any)=>{
//                             if (RTCRtpReceiver.track) RTCRtpReceiver.track.enabled = false;
//                         });
//                         // Stop all the outbound streams (especially useful for Conference Calls!!)
//                         pc.getSenders().forEach((RTCRtpSender:any)=>{
//                             // Mute Audio
//                             if(RTCRtpSender.track && RTCRtpSender.track.kind == "audio") {
//                                 if(RTCRtpSender.track.IsMixedTrack == true){
//                                     if(session.data.AudioSourceTrack && session.data.AudioSourceTrack.kind == "audio"){
//                                         //console.log("Muting Mixed Audio Track : "+ session.data.AudioSourceTrack.label);
//                                         session.data.AudioSourceTrack.enabled = false;
//                                     }
//                                 }
//                                 //console.log("Muting Audio Track : "+ RTCRtpSender.track.label);
//                                 RTCRtpSender.track.enabled = false;
//                             }
//                             // Stop Video
//                             else if(RTCRtpSender.track && RTCRtpSender.track.kind == "video"){
//                                 RTCRtpSender.track.enabled = false;
//                             }
//                         });
//                     }
//                     session.isOnHold = true;
//                     //console.log("Call is is on hold:", session);
//                     this.headerVariableService.browserPhoneTitle = this.lang.call_on_hold;
//                     // Log Hold
//                     if(!session.data.hold) session.data.hold = [];
//                     session.data.hold.push({ event: "hold", eventTime: this.utcDateNow() });
//                 },
//                 onReject: ()=>{
//                     session.isOnHold = false;
//                     console.warn("Failed to put the call on hold:", session);
//                 }
//             }
//         };
//         session.invite(options).catch((error:any)=>{
//             session.isOnHold = false;
//             console.warn("Error attempting to put the call on hold:", error);
//         });
//     }


//     unholdSession(sessionData:any) {
//         //console.log("I am in unholdSession");
//         let session = sessionData;
//         if(session.isOnHold == false) {
//             //console.log("Call is already off hold:", session);
//             return;
//         }
//         //console.log("Taking call off hold:", session);
//         session.isOnHold = false;
    
//         let sessionDescriptionHandlerOptions = session.sessionDescriptionHandlerOptionsReInvite;
//         sessionDescriptionHandlerOptions.hold = false;
//         session.sessionDescriptionHandlerOptionsReInvite = sessionDescriptionHandlerOptions;
    
//         let options = {
//             requestDelegate: {
//                 onAccept: ()=>{
//                     if(session && session.sessionDescriptionHandler && session.sessionDescriptionHandler.peerConnection){
//                         let pc = session.sessionDescriptionHandler.peerConnection;
//                         // Restore all the inbound streams
//                         pc.getReceivers().forEach((RTCRtpReceiver:any)=>{
//                             if (RTCRtpReceiver.track) RTCRtpReceiver.track.enabled = true;
//                         });
//                         // Restore all the outbound streams
//                         pc.getSenders().forEach((RTCRtpSender:any)=>{
//                             // Unmute Audio
//                             if(RTCRtpSender.track && RTCRtpSender.track.kind == "audio") {
//                                 if(RTCRtpSender.track.IsMixedTrack == true){
//                                     if(session.data.AudioSourceTrack && session.data.AudioSourceTrack.kind == "audio"){
//                                         //console.log("Unmuting Mixed Audio Track : "+ session.data.AudioSourceTrack.label);
//                                         session.data.AudioSourceTrack.enabled = true;
//                                     }
//                                 }
//                                 //console.log("Unmuting Audio Track : "+ RTCRtpSender.track.label);
//                                 RTCRtpSender.track.enabled = true;
//                             }
//                             else if(RTCRtpSender.track && RTCRtpSender.track.kind == "video") {
//                                 RTCRtpSender.track.enabled = true;
//                             }
//                         });
//                     }
//                     session.isOnHold = false;
//                     //console.log("Call is off hold:", session);

//                     this.headerVariableService.browserPhoneTitle = this.lang.call_in_progress;
//                     // Log Hold
//                     if(!session.data.hold) session.data.hold = [];
//                     session.data.hold.push({ event: "unhold", eventTime: this.utcDateNow() });
//                 },
//                 onReject: ()=>{
//                     session.isOnHold = true;
//                     console.warn("Failed to put the call on hold", session);
//                 }
//             }
//         };
//         session.invite(options).catch((error:any)=>{
//             session.isOnHold = true;
//             console.warn("Error attempting to take to call off hold", error);
//         });
//     }
    
//     muteSession(sessionData:any){
//         //console.log("I am in muteSession");
//         let session = sessionData;
//         let pc = session.sessionDescriptionHandler.peerConnection;
//         pc.getSenders().forEach((RTCRtpSender) => {
//             if(RTCRtpSender.track && RTCRtpSender.track.kind == "audio") {
//                 if(RTCRtpSender.track.IsMixedTrack == true){
//                     if(session.data.AudioSourceTrack && session.data.AudioSourceTrack.kind == "audio"){
//                         //console.log("Muting Mixed Audio Track : "+ session.data.AudioSourceTrack.label);
//                         session.data.AudioSourceTrack.enabled = false;
//                     }
//                 }
//                 //console.log("Muting Audio Track : "+ RTCRtpSender.track.label);
//                 RTCRtpSender.track.enabled = false;
//             }
//         });
    
//         if(!session.data.mute) session.data.mute = [];
//         session.data.mute.push({ event: "mute", eventTime: this.utcDateNow() });
//         session.data.ismute = true;
//         this.headerVariableService = this.lang.call_on_mute;
//     }
    
//     unmuteSession(sessionData:any){
//         //console.log("I am in unmuteSession");
//         let session = sessionData;
//         let pc = session.sessionDescriptionHandler.peerConnection;
//         pc.getSenders().forEach((RTCRtpSender) =>{
//             if(RTCRtpSender.track && RTCRtpSender.track.kind == "audio") {
//                 if(RTCRtpSender.track.IsMixedTrack == true){
//                     if(session.data.AudioSourceTrack && session.data.AudioSourceTrack.kind == "audio"){
//                         //console.log("Unmuting Mixed Audio Track : "+ session.data.AudioSourceTrack.label);
//                         session.data.AudioSourceTrack.enabled = true;
//                     }
//                 }
//                 //console.log("Unmuting Audio Track : "+ RTCRtpSender.track.label);
//                 RTCRtpSender.track.enabled = true;
//             }
//         });
    
//         if(!session.data.mute) session.data.mute = [];
//         session.data.mute.push({ event: "unmute", eventTime: this.utcDateNow() });
//         session.data.ismute = false;
//         this.headerVariableService.browserPhoneTitle = this.lang.call_off_mute;
//     }
    
    
//     endSession(sessionData:any) {
//         //console.log("I am in endSession");
//         //console.log("Ending call with: "+ sessionData);
//         sessionData.data.terminateby = "us";
//         sessionData.data.reasonCode = 16;
//         sessionData.data.reasonText = "Normal Call clearing";
    
//         sessionData.bye().catch((e:any)=>{
//             console.warn("Failed to bye the session!", e);
//         });
//         this.headerVariableService.browserPhoneTitle = this.lang.call_ended;
//     }
    
//     sendDTMF(sessionData:any, itemStr:any) {
//         //console.log("I am in sendDTMF");
//         // https://developer.mozilla.org/en-US/docs/Web/API/RTCDTMFSender/insertDTMF
//         let options = {
//             duration: 100,
//             interToneGap: 70
//         }
        
//         if(sessionData.isOnHold == true){
//             if(sessionData.data.childsession){
//                 if(sessionData.data.childsession.state == SessionState.Established){
//                     //console.log("Sending DTMF ("+ itemStr +"): "+ sessionData + " child session");
    
//                     let result = sessionData.data.childsession.sessionDescriptionHandler.sendDtmf(itemStr, options);
//                     if(result){
//                         //console.log("Sent DTMF ("+ itemStr +") child session");
//                     }
//                     else{
//                         //console.log("Failed to send DTMF ("+ itemStr +") child session");
//                     }
//                 }
//                 else {
//                     console.warn("Cannot Send DTMF ("+ itemStr +"): "+ sessionData + " is on hold, and the child session is not established");
//                 }
//             } 
//             else {
//                 console.warn("Cannot Send DTMF ("+ itemStr +"): "+ sessionData + " is on hold, and there is no child session");
//             }
//         } 
//         else {
//             if(sessionData.state == SessionState.Established || sessionData.state == SessionState.Establishing){
//                 //console.log("Sending DTMF ("+ itemStr +"): "+ sessionData);
    
//                 let result = sessionData.sessionDescriptionHandler.sendDtmf(itemStr, options);
//                 if(result){
//                     //console.log("Sent DTMF ("+ itemStr +")");
//                 }
//                 else{
//                     //console.log("Failed to send DTMF ("+ itemStr +")");
//                 }
//                 //console.log(this.lang.send_dtmf + ": "+ itemStr);
//             } 
//             else {
//                 console.warn("Cannot Send DTMF ("+ itemStr +"): "+ sessionData + " session is not establishing or established");
//             }
//         }
//     }
    
//     switchVideoSource(sessionData:any, srcId:any){
//         //console.log("I am in switchVideoSource");
//         let session = sessionData;
//         this.headerVariableService.browserPhoneTitle = this.lang.switching_video_source;
 
//         let supportedConstraints = navigator.mediaDevices.getSupportedConstraints();
//         let constraints = { 
//             audio: false, 
//             video: { deviceId: {} }
//         }
//         if(srcId != "default"){
//             constraints.video.deviceId = { exact: srcId }
//         }
    
//         // Add additional Constraints
//         if(supportedConstraints.frameRate && this.headerVariableService.maxFrameRate != "") {
//             constraints.video["frameRate"] = this.headerVariableService.maxFrameRate;
//         }
//         if(supportedConstraints.height && this.headerVariableService.videoHeight != "") {
//             constraints.video["height"] = this.headerVariableService.videoHeight;
//         }
//         if(supportedConstraints.aspectRatio && this.headerVariableService.videoAspectRatio != "") {
//             constraints.video["aspectRatio"] = this.headerVariableService.videoAspectRatio;
//         }
//         session.data.VideoSourceDevice = srcId;
//         let pc = session.sessionDescriptionHandler.peerConnection;
//         let localStream = new MediaStream();

//         navigator.mediaDevices.getUserMedia(constraints).then((newStream:any)=>{
//             let newMediaTrack = newStream.getVideoTracks()[0];
//             pc.getSenders().forEach((RTCRtpSender) =>{
//                 if(RTCRtpSender.track && RTCRtpSender.track.kind == "video") {
//                     //console.log("Switching Video Track : "+ RTCRtpSender.track.label + " to "+ newMediaTrack.label);
//                     RTCRtpSender.track.stop();
//                     RTCRtpSender.replaceTrack(newMediaTrack);
//                     localStream.addTrack(newMediaTrack);
//                 }
//             });
//         }).catch((e:any)=>{
//             console.error("Error on getUserMedia", e, constraints);
//         });
    
//         // Restore Audio Stream is it was changed
//         if(session.data.AudioSourceTrack && session.data.AudioSourceTrack.kind == "audio"){
//             pc.getSenders().forEach((RTCRtpSender:any) =>{
//                 if(RTCRtpSender.track && RTCRtpSender.track.kind == "audio") {
//                     RTCRtpSender.replaceTrack(session.data.AudioSourceTrack).then(()=>{
//                         if(session.data.ismute){
//                             RTCRtpSender.track.enabled = false;
//                         }
//                         else {
//                             RTCRtpSender.track.enabled = true;
//                         }
//                     }).catch(()=>{
//                         //console.error();
//                     });
//                     session.data.AudioSourceTrack = null;
//                 }
//             });
//         }
    
//       //  Set Preview
//       //console.log("Showing as preview...");
//       let localVideo = this.headerVariableService.localVideo;
//       localVideo.srcObject = localStream;
//       localVideo.onloadedmetadata = (e:any)=> {
//           localVideo.play();
//      }
//     }

//     sendVideo(sessionData:any, src:any){
//         //console.log("I am in sendVideo");
//         let session = sessionData;
//         // Create Video Object
//         let newVideo:any =this.headerVariableService.sharedVideo;
//         newVideo.prop("src", src);
//         newVideo.off("loadedmetadata");
//         newVideo.on("loadedmetadata", ()=> {
//             //console.log("Video can play now... ");
    
//             // Resample Video
//             let ResampleSize = 360;
//             if(this.headerVariableService.videoResampleSize == "HD") ResampleSize = 720;
//             if(this.headerVariableService.videoResampleSize == "FHD") ResampleSize = 1080;
    
//             let videoObj = newVideo.get(0);
//             let resampleCanvas:any = this.headerVariableService.resampleCanvas;
    
//             let videoWidth = videoObj.videoWidth;
//             let videoHeight = videoObj.videoHeight;

//             if(videoWidth >= videoHeight){
//                 // Landscape / Square
//                 if(videoHeight > ResampleSize){
//                     let p = ResampleSize / videoHeight;
//                     videoHeight = ResampleSize;
//                     videoWidth = videoWidth * p;
//                 }
//             }
//             else {
//                 // Portrait... (phone turned on its side)
//                 if(videoWidth > ResampleSize){
//                     let p = ResampleSize / videoWidth;
//                     videoWidth = ResampleSize;
//                     videoHeight = videoHeight * p;
//                 }
//             }
    
//             resampleCanvas.width = videoWidth;
//             resampleCanvas.height = videoHeight;
//             let resampleContext = resampleCanvas.getContext("2d");
    
//             window.clearInterval(session.data.videoResampleInterval);
//             session.data.videoResampleInterval = window.setInterval(()=>{
//                resampleContext.drawImage(videoObj, 0, 0, videoWidth, videoHeight);
//             }, 40); // 25frames per second
    
//             // Capture the streams
//             let videoMediaStream = null;
//             if('captureStream' in videoObj) {
//                 videoMediaStream = videoObj.captureStream();
//             }
//             else if('mozCaptureStream' in videoObj) {
//                 // This doesn't really work?
//                 // see: https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/captureStream
//                 videoMediaStream = videoObj.mozCaptureStream();
//             }
//             else {
//                 // This is not supported??.
//                 videoMediaStream = videoObj.webkitCaptureStream();
//                 console.warn("Cannot capture stream from video, this will result in no audio being transmitted.")
//             }

//             let resampleVideoMediaStream = resampleCanvas.captureStream(25);
    
//             // Get the Tracks
//             let videoMediaTrack = resampleVideoMediaStream.getVideoTracks()[0];
//             let audioTrackFromVideo = (videoMediaStream != null )? videoMediaStream.getAudioTracks()[0] : null;
    
//             // Switch & Merge Tracks
//             let pc = session.sessionDescriptionHandler.peerConnection;
//             pc.getSenders().forEach((RTCRtpSender)=> {
//                 if(RTCRtpSender.track && RTCRtpSender.track.kind == "video") {
//                     //console.log("Switching Track : "+ RTCRtpSender.track.label);
//                     RTCRtpSender.track.stop();
//                     RTCRtpSender.replaceTrack(videoMediaTrack);
//                 }
//                 if(RTCRtpSender.track && RTCRtpSender.track.kind == "audio") {
//                     //console.log("Switching to mixed Audio track on session");
                    
//                     session.data.AudioSourceTrack = RTCRtpSender.track;
    
//                     let mixedAudioStream = new MediaStream();
//                     if(audioTrackFromVideo) mixedAudioStream.addTrack(audioTrackFromVideo);
//                     mixedAudioStream.addTrack(RTCRtpSender.track);
//                     let mixedAudioTrack = this.mixAudioStreams(mixedAudioStream).getAudioTracks()[0];
//                     mixedAudioTrack.IsMixedTrack = true;
    
//                     RTCRtpSender.replaceTrack(mixedAudioTrack);
//                 }
//             });
    
//             // Set Preview
//             //console.log("Showing as preview...");
//             let localVideo:any = '$("#line-" + lineNum + "-localVideo").get(0)';
//            localVideo.srcObject = videoMediaStream;
//             localVideo.onloadedmetadata = (e:any)=> {
//                localVideo.play().then(()=>{
//                     //console.log("Playing Preview Video File");
//                 }).catch((e:any)=>{
//                     console.error("Cannot play back video", e);
//                 });
//             }
//             // Play the video
//             //console.log("Starting Video...");
//             videoObj.play();
//         });
//         //console.log("Video for Sharing created...");
//     }
    

//     shareScreen(sessionData:any){
//         //console.log("I am in shareScreen");
//         let session = sessionData;
//         this.headerVariableService.browserPhoneTitle = this.lang.switching_to_shared_screen;
//         let localStream = new MediaStream();
//         let pc = session.sessionDescriptionHandler.peerConnection;
    
//         // TODO: Remove legacy ones
//         if (navigator.mediaDevices.getDisplayMedia) {
//             // EDGE, legacy support
//             let screenShareConstraints = { video: true, audio: false }
//             navigator.mediaDevices.getDisplayMedia(screenShareConstraints).then((newStream:any)=> {
//                 //console.log("navigator.getDisplayMedia")
//                 let newMediaTrack = newStream.getVideoTracks()[0];
//                 pc.getSenders().forEach((RTCRtpSender)=> {
//                     if(RTCRtpSender.track && RTCRtpSender.track.kind == "video") {
//                         //console.log("Switching Video Track : "+ RTCRtpSender.track.label + " to Screen");
//                         RTCRtpSender.track.stop();
//                         RTCRtpSender.replaceTrack(newMediaTrack);
//                         localStream.addTrack(newMediaTrack);
//                     }
//                 });
    
//                 // Set Preview
//                 // ===========
//                 //console.log("Showing as preview...");
//                 let localVideo :any = this.headerVariableService.localVideo;
//                 localVideo.srcObject = localStream;
//                 localVideo.onloadedmetadata = (e:any)=> {
//                     localVideo.play();
//                }
//             }).catch((err:any) =>{
//                 console.error("Error on getUserMedia");
//                 console.error(err);
//             });
//         } 
//         else if (navigator.mediaDevices.getDisplayMedia) {
//             // New standard
//             let screenShareConstraints = { video: true, audio: false }
//             navigator.mediaDevices.getDisplayMedia(screenShareConstraints).then((newStream:any)=> {
//                 //console.log("navigator.mediaDevices.getDisplayMedia")
//                 let newMediaTrack = newStream.getVideoTracks()[0];
//                 pc.getSenders().forEach((RTCRtpSender:any) =>{
//                     if(RTCRtpSender.track && RTCRtpSender.track.kind == "video") {
//                         //console.log("Switching Video Track : "+ RTCRtpSender.track.label + " to Screen");
//                         RTCRtpSender.track.stop();
//                         RTCRtpSender.replaceTrack(newMediaTrack);
//                         localStream.addTrack(newMediaTrack);
//                     }
//                 });
    
//                 // Set Preview
//                 // ===========
//                 //console.log("Showing as preview...");
//                 let localVideo :any=this.headerVariableService.localVideo;
//                 localVideo.srcObject = localStream;
//                 localVideo.onloadedmetadata = (e:any)=> {
//                     localVideo.play();
//                 }
//             }).catch((err:any) =>{
//                 console.error("Error on getUserMedia");
//                 console.error(err);
//             });
//         } 
//         else {
//             // Firefox, apparently
//             let screenShareConstraints:any = { video: { mediaSource: 'screen' }, audio: false }
//             navigator.mediaDevices.getUserMedia(screenShareConstraints).then((newStream:any)=> {
//                 //console.log("navigator.mediaDevices.getUserMedia")
//                 let newMediaTrack = newStream.getVideoTracks()[0];
//                 pc.getSenders().forEach((RTCRtpSender:any)=> {
//                     if(RTCRtpSender.track && RTCRtpSender.track.kind == "video") {
//                         //console.log("Switching Video Track : "+ RTCRtpSender.track.label + " to Screen");
//                         RTCRtpSender.track.stop();
//                         RTCRtpSender.replaceTrack(newMediaTrack);
//                         localStream.addTrack(newMediaTrack);
//                     }
//                 });
    
//                 // Set Preview
//                 //console.log("Showing as preview...");
//                 let localVideo:any = this.headerVariableService.localVideo;
//                 localVideo.srcObject = localStream;
//                 localVideo.onloadedmetadata = (e:any)=> {
//                     localVideo.play();
//                 }
//             }).catch((err:any)=> {
//                 console.error("Error on getUserMedia");
//                 console.error(err);
//             });
//         }
    
//         // Restore Audio Stream is it was changed
//         if(session.data.AudioSourceTrack && session.data.AudioSourceTrack.kind == "audio"){
//             pc.getSenders().forEach((RTCRtpSender:any)=> {
//                 if(RTCRtpSender.track && RTCRtpSender.track.kind == "audio") {
//                     RTCRtpSender.replaceTrack(session.data.AudioSourceTrack).then(()=>{
//                         if(session.data.ismute){
//                             RTCRtpSender.track.enabled = false;
//                         }
//                         else {
//                             RTCRtpSender.track.enabled = true;
//                         }
//                     }).catch((e:any)=>{
//                        console.error(e);
//                     });
//                     session.data.AudioSourceTrack = null;
//                 }
//             });
//         }
    
//     }

//     disableVideoStream(sessionData:any){
//         //console.log("I am in disableVideoStream");
//         let session = sessionData;
    
//         let pc = session.sessionDescriptionHandler.peerConnection;
//         pc.getSenders().forEach((RTCRtpSender:any) =>{
//             if(RTCRtpSender.track && RTCRtpSender.track.kind == "video") {
//                 //console.log("Disable Video Track : "+ RTCRtpSender.track.label + "");
//                 RTCRtpSender.track.enabled = false; //stop();
//             }
//             if(RTCRtpSender.track && RTCRtpSender.track.kind == "audio") {
//                 if(session.data.AudioSourceTrack && session.data.AudioSourceTrack.kind == "audio"){
//                     RTCRtpSender.replaceTrack(session.data.AudioSourceTrack).then(()=>{
//                         if(session.data.ismute){
//                             RTCRtpSender.track.enabled = false;
//                         }
//                         else {
//                             RTCRtpSender.track.enabled = true;
//                         }
//                     }).catch((e:any)=>{
//                         console.error(e);
//                     });
//                     session.data.AudioSourceTrack = null;
//                 }
//             }
//         });
    
//         // Set Preview
//         //console.log("Showing as preview...");
//         let localVideo :any= this.headerVariableService.localVideo;
//         localVideo.pause();
//         localVideo.removeAttribute('src');
//         localVideo.load();
//         this.headerVariableService.browserPhoneTitle = this.lang.video_disabled;
//     }

//     userLocale(){
//         //console.log("I am in userLocale");
//         let language = window.navigator.language || window.navigator.language; // "en", "en-US", "fr", "fr-FR", "es-ES", etc.
//         // langtag = language["-"script]["-" region] *("-" variant) *("-" extension) ["-" privateuse]
//         // TODO Needs work
//         let langtag = language.split('-');
//         if(langtag.length == 1){
//             return ""; 
//         } 
//         else if(langtag.length == 2) {
//             return langtag[1].toLowerCase();  // en-US => us
//         }
//         else if(langtag.length >= 3) {
//             return langtag[1].toLowerCase();  // en-US => us
//         }
//     }

//     uID(){
//         //console.log("I am in uID");
//         return Date.now()+Math.floor(Math.random()*10000).toString(16).toUpperCase();
//     }
    
//     utcDateNow(){
//         //console.log("I am in utcDateNow");
//         return moment.utc().format("YYYY-MM-DD HH:mm:ss UTC");
//     }

//     formatShortDuration(seconds:any){
//       //console.log("I am in formatShortDuration");
//       let sec = Math.floor(parseFloat(seconds));
//       if(sec < 0){
//           return sec;
//       } 
//       else if(sec >= 0 && sec < 60){
//           return "00:"+ ((sec > 9)? sec : "0"+sec );
//       } 
//       else if(sec >= 60 && sec < 60 * 60){ // greater then a minute and less then an hour
//           let duration = moment.duration(sec, 'seconds');
//           return ((duration.minutes() > 9)? duration.minutes() : "0"+duration.minutes()) + ":" + ((duration.seconds() > 9)? duration.seconds() : "0"+duration.seconds());
//       } 
//       else if(sec >= 60 * 60 && sec < 24 * 60 * 60){ // greater than an hour and less then a day
//           let duration = moment.duration(sec, 'seconds');
//           return ((duration.hours() > 9)? duration.hours() : "0"+duration.hours())  + ":" + ((duration.minutes() > 9)? duration.minutes() : "0"+duration.minutes())  + ":" + ((duration.seconds() > 9)? duration.seconds() : "0"+duration.seconds());
//       } 
//       //  Otherwise.. this is just too long
//     }
    
//     countSessions(id:any){
//     //   //console.log("I am in countSessions");
//     //   //console.log("My Id : ",id);

//       let rtn = 0;
//       if(this.userAgent == null) {
//         console.warn("userAgent is null");
//           return 0;
//       }

//       //console.log("User Agent within count session : ")
//      //console.log(JSON.stringify(this.userAgent._sessions));
//      // //console.log(this.userAgent._sessions);
    
//       this.userAgent.sessions=this.userAgent._sessions;
//     //   //console.log(Object.keys(this.userAgent.sessions));

//       Object.keys(this.userAgent.sessions).forEach((session:any,i:any)=> {
//           if(String(id) != session) rtn ++;
//       });


//      //console.log("Current call count: ",rtn);

//       return rtn;
//     }

//     // Stream Manipulations
//     // ====================
//     mixAudioStreams(MultiAudioTackStream:any){
//       //console.log("I am in mixAudioStreams");
//       // Takes in a MediaStream with any number of audio tracks and mixes them together
//       let audioContext = null;
//       try {
//           window.AudioContext = window.AudioContext;
//           audioContext = new AudioContext();
//       }
//       catch(e){
//         console.warn("AudioContext() not available, cannot record");
//           return MultiAudioTackStream;
//       }
//       let mixedAudioStream = audioContext.createMediaStreamDestination();
//       MultiAudioTackStream.getAudioTracks().forEach((audioTrack:any)=>{
//           let srcStream = new MediaStream();
//           srcStream.addTrack(audioTrack);
//           let streamSourceNode = audioContext.createMediaStreamSource(srcStream);
//           streamSourceNode.connect(mixedAudioStream);
//       });

//       return mixedAudioStream.stream;
//     }

//     // Device Detection
//     // ================
//     detectDevices() {

//       //console.log("I am in detectDevices");
//       //console.log('verify permissions');

//       const microphone = "microphone" as PermissionName;
//       const camera = "camera" as PermissionName;

//       navigator.permissions.query({name: microphone})
//       .then((permissionObj) => {
//         //console.log(permissionObj.state);
//         let now = Date.now();
//         switch(permissionObj.state)
//         {
//               case 'granted': 
//                                   navigator.permissions.query({name: camera})
//                                   .then((permissionObj) => {
//                                     //console.log(permissionObj.state);
//                                     switch(permissionObj.state)
//                                     {
//                                           case 'granted':
//                                                               //console.log('detectDevices');
//                                                               navigator.mediaDevices.enumerateDevices().then((deviceInfos:any)=>{
//                                                                 // deviceInfos will not have a populated lable unless to accept the permission
//                                                                 // during getUserMedia. This normally happens at startup/setup
//                                                                 // so from then on these devices will be with lables.
//                                                               //console.log('inside navigator');
//                                                                 this.headerVariableService.hasVideoDevice = false;
//                                                                 this.headerVariableService.hasAudioDevice = false;
//                                                                 this.headerVariableService.hasSpeakerDevice = false; // Safari and Firefox don't have these
//                                                                 this.headerVariableService.micList = [];
//                                                                 this.headerVariableService.videoList = [];
//                                                                 this.headerVariableService.speakerList = [];
//                                                                 //console.log('deviceInfos',deviceInfos);
//                                                                 for (let i = 0; i < deviceInfos.length; ++i) {
//                                                                     if (deviceInfos[i].kind === "audioinput") {
//                                                                       this.headerVariableService.hasAudioDevice = true;
//                                                                       this.headerVariableService.micList.push(deviceInfos[i].deviceId);
//                                                                     } 
//                                                                     else if (deviceInfos[i].kind === "audiooutput") {
//                                                                       this.headerVariableService.hasSpeakerDevice = true;
//                                                                       this.headerVariableService.speakerList.push(deviceInfos[i].deviceId);
//                                                                     }
//                                                                     else if (deviceInfos[i].kind === "videoinput") {
//                                                                           this.headerVariableService.hasVideoDevice = true;
//                                                                           this.headerVariableService.videoList.push(deviceInfos[i].deviceId);
//                                                                     }
//                                                                 }
//                                                                 //console.log(this.headerVariableService.micList, this.headerVariableService.videoList);
//                                                                 //Setting up letible values aysn. This is an example on how observers are created to do parallel job
//                                                                 this.headerVariableService.setMicDeviceVariable();
//                                                                 this.headerVariableService.setVideoDeviceVariable();
//                                                                 this.headerVariableService.setSpeakerDeviceVariable();
//                                                             }).catch((e:any)=>{
//                                                               console.error("Error enumerating devices", e);
//                                                             });
                                                
//                                                 break;
                            
//                                                 case 'denied': 
//                                                 //console.log('case denied: asking permissions for video');
//                                                 this.showDialoge('Error','activity-outline','danger', "Camera permission is required to use this web-app. Contact admin."); 
//                                                 break;
                                  
//                                                 case 'prompt': 
                                                                          
//                                                                           this.showDialoge('Information','activity-outline','success', "Camera permission is required to use this web-app."); 
//                                                                           //console.log('case prompt: asking permissions for video');
//                                                                           navigator.mediaDevices.getUserMedia({audio: false, video: true})
//                                                                           .then((stream) =>{
//                                                                             //console.log('case prompt: Got stream, time diff :', Date.now() - now);
//                                                                             //console.log(stream);
//                                                                             stream.getTracks().forEach((track)=> {
//                                                                               //console.log(track);
//                                                                               track.stop();
//                                                                             });
//                                                                           })
//                                                                           .catch((err) =>{
//                                                                             //console.log('case prompt: GUM failed with error, time diff: ', Date.now() - now);
//                                                                             //DOMException: Permission denied
//                                                                             if(String(err).includes('Permission denied'))
//                                                                             {
//                                                                               this.showDialoge('Error','activity-outline','danger', "Camera permission is required to use this web-app. Contact admin."); 
//                                                                                //this.detectDevices();
//                                                                             }
//                                                                             //console.log(err);
//                                                                           });
//                                                       break;
                            
//                                           default: break;
//                                     }
//                                   })
//                                   .catch((error) => {
//                                     //console.log('Got error :', error);
//                                   })
//                     break;

//               case 'denied': 
//                                     //console.log('case denied: asking permissions for audio');
//                                     this.showDialoge('Error','activity-outline','danger', "Microphone permission is required to use this web-app. Contact admin."); 
//                      break;

//               case 'prompt': 
                                        
//                                         this.showDialoge('Information','activity-outline','success', "Microphone permission is required to use this web-app."); 
//                                         //console.log('case prompt: asking permissions for audio');
//                                         navigator.mediaDevices.getUserMedia({audio: true, video: false})
//                                         .then((stream) =>{
//                                           //console.log('case prompt: Got stream, time diff :', Date.now() - now);
//                                           //console.log(stream);
//                                           stream.getTracks().forEach((track)=> {
//                                             //console.log(track);
//                                             track.stop();
//                                           });
//                                           this.detectDevices();
//                                         })
//                                         .catch((err) =>{
//                                           //console.log('case prompt: GUM failed with error, time diff: ', Date.now() - now);
//                                           //DOMException: Permission denied
//                                           if(String(err).includes('Permission denied'))
//                                           {
//                                             this.showDialoge('Error','activity-outline','danger', "Microphone permission is required to use this web-app. Contact admin."); 
//                                              //this.detectDevices();
//                                           }
//                                           //console.log(err);
//                                         });
//                     break;
//               default: break;
//         }

//       })
//       .catch((error) => {
//         //console.log('Got error :', error);
//       })
//     }

//     ngOnDestroy() {
//       //console.log("header-OnDestroy");
//         this.sendAync.next();
//         this.sendAync.complete();
//       }

//    showDialoge(header: string,icon: string,status: string, message:string) {

//         this.dialogService.open(DialogComponent, {
//           context: {
//             title: status,
//             data: message,
//             header: header,
//             icon: icon
//           },
//         });
//         }
// }